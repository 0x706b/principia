import * as A from "@principia/base/Array";
import { Either } from "@principia/base/Either";
import * as E from "@principia/base/Either";
import { Eq } from "@principia/base/Eq";
import {
   constant,
   flow,
   identity,
   Lazy,
   pipe,
   Predicate,
   Refinement,
   tuple
} from "@principia/base/Function";
import * as I from "@principia/base/Iterable";
import * as Mb from "@principia/base/Maybe";
import { Maybe } from "@principia/base/Maybe";
import * as NEA from "@principia/base/NonEmptyArray";
import { NonEmptyArray } from "@principia/base/NonEmptyArray";
import { Separated } from "@principia/base/Utils";

import type { Cause, RuntimeError } from "../Cause";
import * as C from "../Cause";
import { Clock, currentTime, HasClock, sleep as clockSleep } from "../Clock";
import type { Effect, IO, RIO, UIO } from "../Common/effect-base";
import * as T from "../Common/effect-base";
import { OverrideForkScopeInstruction } from "../Common/Effect/instructions";
import { ExecutionStrategy, Parallel, ParallelN, Sequential } from "../Common/ExecutionStrategy";
import type { Scope } from "../Common/Fiber/Scope";
import * as FR from "../Common/FiberRef";
import { Has, Tag } from "../Common/Has";
import * as L from "../Common/Layer";
import * as M from "../Common/managed-base";
import { Managed } from "../Common/managed-base";
import * as Par from "../Common/parallel";
import * as Super from "../Common/Supervisor";
import * as XP from "../Common/XPromise";
import * as XR from "../Common/XRef";
import * as XRM from "../Common/XRefM";
import type { Exit } from "../Exit";
import * as Ex from "../Exit";
import * as Fiber from "../Fiber";
import { FiberId } from "../Fiber/FiberId";
import { NoSuchElementException } from "../GlobalExceptions";
import * as S from "../Schedule";

/**
 * ```haskell
 * absolve :: Effect t => t s r e (Either e1 a) -> t s r (e | e1) a
 * ```
 *
 * Returns an effect that submerges the error case of an `Either` into the
 * `Effect`.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const absolve = T.absolve;

export const environment = T.environment;

export const fork = T.fork;

/**
 * ```haskell
 * sandbox :: Effect t => t x r e a -> t x r (Cause e) a
 * ```
 *
 * Exposes the full cause of failure of this effect.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const sandbox: <R, E, A>(ef: Effect<R, E, A>) => Effect<R, Cause<E>, A> = T.foldCauseM(
   T.fail,
   T.pure
);

/**
 * ```haskell
 * _absorbWith :: Effect t => (t x r e a, (e -> _)) -> t x r _ a
 * ```
 *
 * Attempts to convert defects into a failure, throwing away all information
 * about the cause of the failure.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _absorbWith = <R, E, A>(ef: Effect<R, E, A>, f: (e: E) => unknown) =>
   pipe(ef, sandbox, T.foldM(flow(C.squash(f), T.fail), T.pure));

/**
 * ```haskell
 * absorbWith :: Effect t => (e -> _) -> t x r e a -> t x r _ a
 * ```
 * Attempts to convert defects into a failure, throwing away all information
 * about the cause of the failure.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const absorbWith = <E>(f: (e: E) => unknown) => <R, A>(
   ef: Effect<R, E, A>
): Effect<R, unknown, A> => _absorbWith(ef, f);

/**
 * ```haskell
 * _as :: Effect t => (t x r e a, b) -> t x r e b
 * ```
 *
 * Maps the success value of this effect to the specified constant value.
 */
export const _as = T._as;

/**
 * ```haskell
 * as :: Effect t => b -> t x r e a -> t x r e b
 * ```
 *
 * Maps the success value of this effect to the specified constant value.
 */
export const as = T.as;

/**
 * ```haskell
 * asService :: Effect t => Tag a -> t x r e a -> t x r e (Has a)
 * ```
 *
 * Maps the success value of this effect to a service.
 */
export const asService = <A>(has: Tag<A>) => <R, E>(ef: Effect<R, E, A>) => T._map(ef, has.of);

/**
 * ```haskell
 * asJust :: Effect t => t x r e a -> t x r e (Maybe a)
 * ```
 *
 * Maps the success value of this effect to an optional value.
 */
export const asJust = <R, E, A>(ef: Effect<R, E, A>) => T._map(ef, Mb.just);

/**
 * ```haskell
 * asJustError :: Effect t => t x r e a -> t x r (Maybe e) a
 * ```
 *
 * Maps the error value of this effect to an optional value.
 */
export const asJustError = T.asJustError;

/**
 * ```haskell
 * asUnit :: Effect t => t x r e a -> t x r e ()
 * ```
 *
 * Ignores the result of the effect replacing it with a void
 */
export const asUnit = T.asUnit;

/**
 * ```haskell
 * _bracketExit :: Effect t => (
 *    t x r e a,
 *    (a -> x x1 r1 e1 b),
 *    ((a, (Exit e1 b)) -> x x2 r2 e2 _)
 * ) -> t (x | x1 | x2) (r & r1 & r2) (e | e1 | e2) b
 * ```
 *
 * Acquires a resource, uses the resource, and then releases the resource.
 * Neither the acquisition nor the release will be interrupted, and the
 * resource is guaranteed to be released, so long as the `acquire` effect
 * succeeds. If `use` fails, then after release, the returned effect will fail
 * with the same error.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _bracketExit = T._bracketExit;


export const _bracket = T._bracket;


/**
 * ```haskell
 * _bracketFiber :: Effect t => (
 *    t x r e a,
 *    ((FiberRuntime e a) -> t x1 r1 e1 b)
 * ) -> t ^ (r & r1) e1 (Exit e a)
 * ```
 *
 * Fork the effect into a separate fiber wrapping it in a bracket and returining
 * the `use` handle. Acquisition will fork and release will interrupt the fiber
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _bracketFiber = <R, E, A, R1, E1, B>(
   ef: Effect<R, E, A>,
   use: (f: Fiber.Runtime<E, A>) => Effect<R1, E1, B>
) => _bracket(T.forkDaemon(ef), (f) => T._chain(T.checkFiberId(), (id) => f.interruptAs(id)), use);

/**
 * ```haskell
 * bracketFiber :: Effect t => ((FiberRuntime e a) -> t x1 r1 e1 b) ->
 *    t x r e a -> t ^ (r & r1) e1 (Exit e a)
 * ```
 *
 * Fork the effect into a separate fiber wrapping it in a bracket and returining the
 * `use` handle. Acquisition will fork and release will interrupt the fiber
 *
 * @category Combinators
 * @since 1.0.0
 */
export const bracketFiber = <E, A, R1, E1, A1>(
   use: (f: Fiber.Runtime<E, A>) => Effect<R1, E1, A1>
) => <R>(ef: Effect<R, E, A>) => _bracketFiber(ef, use);

/**
 * ```haskell
 * _bracketOnError :: Effect t => (
 *    t x r e a,
 *    (a -> t x1 r1 e1 b),
 *    ((a, (Exit e1 b)) -> t x2 r2 e2 c),
 * ) -> t (x | x1 | x2) (r & r1 & r2) (e | e1 | e2) b
 * ```
 *
 * Same as `_bracketExit` but executes the release effect only if there was an error.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _bracketOnError = <R, E, A, R1, E1, A1, R2, E2, A2>(
   acquire: Effect<R, E, A>,
   use: (a: A) => Effect<R1, E1, A1>,
   release: (a: A, e: Exit<E1, A1>) => Effect<R2, E2, A2>
): Effect<R & R1 & R2, E | E1 | E2, A1> =>
   _bracketExit(acquire, use, (a, e) => (e._tag === "Success" ? T.unit : release(a, e)));

/**
 * ```haskell
 * bracketOnError :: Effect t => (
 *    (a -> t x1 r1 e1 b),
 *    ((a, (Exit e1 b)) -> t x2 r2 e2 c),
 * ) -> t x r e a -> t (x | x1 | x2) (r & r1 & r2) (e | e1 | e2) b
 * ```
 *
 * Same as `bracketExit` but executes the release effect only if there was an error.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const bracketOnError = <A, R1, E1, A1, R2, E2, A2>(
   use: (a: A) => Effect<R1, E1, A1>,
   release: (a: A, e: Exit<E1, A1>) => Effect<R2, E2, A2>
) => <R, E>(acquire: Effect<R, E, A>) => _bracketOnError(acquire, use, release);

const __compute = <R, E, A>(fa: Effect<R, E, A>, ttl: number, start: number) =>
   pipe(
      T.of,
      T.bindS("p", () => XP.make<E, A>()),
      T.tap(({ p }) => T.to(p)(fa)),
      T.map(({ p }) => Mb.just(tuple(start + ttl, p)))
   );

const __get = <R, E, A>(
   fa: Effect<R, E, A>,
   ttl: number,
   cache: XRM.RefM<Maybe<readonly [number, XP.XPromise<E, A>]>>
) =>
   T.uninterruptibleMask(({ restore }) =>
      pipe(
         currentTime,
         T.chain((time) =>
            pipe(
               cache,
               XRM.updateSomeAndGet((o) =>
                  pipe(
                     o,
                     Mb.fold(
                        () => Mb.just(__compute(fa, ttl, time)),
                        ([end]) =>
                           end - time <= 0
                              ? Mb.just(__compute(fa, ttl, time))
                              : Mb.nothing<
                                   Effect<R, never, Maybe<readonly [number, XP.XPromise<E, A>]>>
                                >()
                     )
                  )
               ),
               T.chain((a) => (a._tag === "Nothing" ? T.die("bug") : restore(XP.wait(a.value[1]))))
            )
         )
      )
   );

/**
 * Parallely zips this effects
 */
export const _bothPar = <R, E, A, R1, E1, A1>(ma: Effect<R, E, A>, mb: Effect<R1, E1, A1>) =>
   Par._bothMapPar(ma, mb, (a, b) => [a, b] as const);

/**
 * Parallely zips this effects
 */
export const bothPar = <R1, E1, A1>(mb: Effect<R1, E1, A1>) => <R, E, A>(ma: Effect<R, E, A>) =>
   _bothPar(ma, mb);

/**
 * Sequentially zips this effect with the specified effect using the
 * specified combiner function.
 */
export const _bothMapPar = Par._bothMapPar;

/**
 * Sequentially zips this effect with the specified effect using the
 * specified combiner function.
 */
export const bothMapPar = <A, R1, E1, A1, B>(mb: Effect<R1, E1, A1>, f: (a: A, b: A1) => B) => <
   R,
   E
>(
   ma: Effect<R, E, A>
) => _bothMapPar(ma, mb, f);

/**
 * ```haskell
 * _cached :: Effect t => (t x r e a, Number) -> t _ (r & HasClock) _ (t ^ _ e a)
 * ```
 *
 * Returns an effect that, if evaluated, will return the cached result of
 * this effect. Cached results will expire after `timeToLive` duration.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _cached = <R, E, A>(fa: Effect<R, E, A>, ttl: number): RIO<R & Has<Clock>, IO<E, A>> =>
   pipe(
      T.of,
      T.bindS("r", () => T.environment<R & Has<Clock>>()),
      T.bindS("cache", () =>
         XRM.makeRefM<Maybe<readonly [number, XP.XPromise<E, A>]>>(Mb.nothing())
      ),
      T.map(({ cache, r }) => T.provideAll(r)(__get(fa, ttl, cache)))
   );

/**
 * ```haskell
 * _cached :: Effect t => Number -> t x r e a -> t _ (r & HasClock) _ (t ^ _ e a)
 * ```
 *
 * Returns an effect that, if evaluated, will return the cached result of
 * this effect. Cached results will expire after `timeToLive` duration.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const cached = (ttl: number) => <R, E, A>(fa: Effect<R, E, A>) => _cached(fa, ttl);

/**
 * ```haskell
 * _catchAll :: Effect t => (t x r e a, (e -> t x1 r1 e1 b)) ->
 *    t (x | x1) (r & r1) e1 (a | b)
 * ```
 */
export const _catchAll = T._catchAll;

/**
 * ```haskell
 * _catchAll :: Effect t => (e -> t x1 r1 e1 b) -> t x r e a ->
 *    t (x | x1) (r & r1) e1 (a | b)
 * ```
 */
export const catchAll = T.catchAll;


/**
 * Takes some fiber failures and converts them into errors, using the
 * specified function to convert the `E` into an `E1 | E2`.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _unrefineWith = <R, E, A, E1, E2>(
   ef: Effect<R, E, A>,
   pf: (u: unknown) => Maybe<E1>,
   f: (e: E) => E2
): Effect<R, E1 | E2, A> =>
   _catchAllCause(
      ef,
      (cause): Effect<R, E1 | E2, A> =>
         pipe(
            cause,
            C.find(pf),
            Mb.fold(() => pipe(cause, C.map(f), T.halt), T.fail)
         )
   );

/**
 * Takes some fiber failures and converts them into errors, using the
 * specified function to convert the `E` into an `E1 | E2`.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const unrefineWith = <E1>(pf: (u: unknown) => Maybe<E1>) => <E, E2>(f: (e: E) => E2) => <
   X,
   R,
   A
>(
   ef: Effect<R, E, A>
) => _unrefineWith(ef, pf, f);

/**
 * Takes some fiber failures and converts them into errors.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _unrefine = <R, E, A, E1>(ef: Effect<R, E, A>, pf: (u: unknown) => Maybe<E1>) =>
   _unrefineWith(ef, pf, identity);

/**
 * Takes some fiber failures and converts them into errors.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const unrefine = <E1>(pf: (u: unknown) => Maybe<E1>) => <R, E, A>(ef: Effect<R, E, A>) =>
   _unrefine(ef, pf);

/**
 * Recovers from some or all of the defects with provided partial function.
 *
 * *WARNING*: There is no sensible way to recover from defects. This
 * method should be used only at the boundary between Effect and an external
 * system, to transmit information on a defect for diagnostic or explanatory
 * purposes.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _catchSomeDefect = <R, E, A, R1, E1, A1>(
   ef: Effect<R, E, A>,
   f: (_: unknown) => Maybe<Effect<R1, E1, A1>>
) => _catchAll(_unrefineWith(ef, f, fail), (s): Effect<R1, E | E1, A1> => s);

/**
 * Recovers from some or all of the defects with provided partial function.
 *
 * *WARNING*: There is no sensible way to recover from defects. This
 * method should be used only at the boundary between Effect and an external
 * system, to transmit information on a defect for diagnostic or explanatory
 * purposes.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const catchSomeDefect = <R1, E1, A1>(f: (_: unknown) => Maybe<Effect<R1, E1, A1>>) => <
   R,
   E,
   A
>(
   ef: Effect<R, E, A>
) => _catchSomeDefect(ef, f);

export const cause = T.cause;

export const causeAsError = <R, E, A>(ef: Effect<R, E, A>) => T._foldCauseM(ef, T.fail, T.pure);

export const errorAsCause = <R, E, A>(ef: Effect<R, Cause<E>, A>) => T._foldM(ef, T.halt, T.pure);

/**
 *  Swaps the error/value parameters, applies the function `f` and flips the parameters back
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _swapWith = <R, E, A, R1, E1, A1>(
   ef: Effect<R, E, A>,
   f: (ef: Effect<R, A, E>) => Effect<R1, A1, E1>
) => T.swap(f(T.swap(ef)));

/**
 *  Swaps the error/value parameters, applies the function `f` and flips the parameters back
 *
 * @category Combinators
 * @since 1.0.0
 */
export const swapWith = <R, E, A, R1, E1, A1>(f: (ef: Effect<R, A, E>) => Effect<R1, A1, E1>) => (
   ef: Effect<R, E, A>
) => _swapWith(ef, f);

export const _chainError = <R, R1, E, E1, A>(
   ef: Effect<R, E, A>,
   f: (e: E) => Effect<R1, never, E1>
) => _swapWith(ef, T.chain(f));

export const chainError = <E, R1, E1>(f: (e: E) => Effect<R1, never, E1>) => <R, A>(
   ef: Effect<R, E, A>
) => _chainError(ef, f);

export const _collectM = <R, E, A, R1, E1, A1, E2>(
   ef: Effect<R, E, A>,
   f: () => E2,
   pf: (a: A) => Maybe<Effect<R1, E1, A1>>
) =>
   T._chain(
      ef,
      (a): Effect<R1, E1 | E2, A1> =>
         pipe(
            pf(a),
            Mb.getOrElse(() => T.fail(f()))
         )
   );

export const collectM = <A, R1, E1, A1, E2>(
   f: () => E2,
   pf: (a: A) => Maybe<Effect<R1, E1, A1>>
) => <R, E>(ef: Effect<R, E, A>) => _collectM(ef, f, pf);

export const _collect = <R, E, A, E1, A1>(
   ef: Effect<R, E, A>,
   f: () => E1,
   pf: (a: A) => Maybe<A1>
) => _collectM(ef, f, flow(pf, Mb.map(T.pure)));

export const collect = <A, E1, A1>(f: () => E1, pf: (a: A) => Maybe<A1>) => <R, E>(
   ef: Effect<R, E, A>
) => _collect(ef, f, pf);

export const collectAll = <R, E, A>(efs: Iterable<Effect<R, E, A>>) => T._foreach(efs, identity);

export const collectAllPar = <R, E, A>(efs: Iterable<Effect<R, E, A>>) =>
   Par._foreachPar(efs, identity);

export const collectAllParN = (n: number) => <R, E, A>(efs: Iterable<Effect<R, E, A>>) =>
   Par._foreachParN(n)(efs, identity);

export const collectAllUnit = <R, E, A>(efs: Iterable<Effect<R, E, A>>) =>
   T._foreachUnit(efs, identity);

export const collectAllUnitPar = <R, E, A>(efs: Iterable<Effect<R, E, A>>) =>
   Par._foreachUnitPar(efs, identity);

export const collectAllUnitParN = (n: number) => <R, E, A>(efs: Iterable<Effect<R, E, A>>) =>
   Par._foreachUnitParN(n)(efs, identity);

export const compose = <R, R1, E1>(that: Effect<R1, E1, R>) => <X, E, A>(ef: Effect<R, E, A>) =>
   T._chain(that, (r) => T._provideAll(ef, r));

/**
 * Acts on the children of this fiber, guaranteeing the specified callback
 * will be invoked, whether or not this effect succeeds.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _ensuringChildren = <R, E, A, R1>(
   ef: Effect<R, E, A>,
   children: (_: ReadonlyArray<Fiber.Runtime<any, any>>) => Effect<R1, never, any>
) =>
   pipe(
      Super.track,
      T.chain((s) =>
         pipe(
            ef,
            T.supervised(s),
            T.ensuring(
               pipe(
                  s.value,
                  T.chain((v) => children(v))
               )
            )
         )
      )
   );

/**
 * Acts on the children of this fiber, guaranteeing the specified callback
 * will be invoked, whether or not this effect succeeds.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const ensuringChildren = <R1>(
   children: (_: ReadonlyArray<Fiber.Runtime<any, any>>) => Effect<R1, never, any>
) => <R, E, A>(ef: Effect<R, E, A>) => _ensuringChildren(ef, children);

/**
 * Returns a new effect that will not succeed with its value before first
 * waiting for the end of all child fibers forked by the effect.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const awaitAllChildren = <R, E, A>(ef: Effect<R, E, A>): Effect<R, E, A> =>
   _ensuringChildren(ef, Fiber.awaitAll);

/**
 * ```haskell
 * sleep :: Effect t => Number -> t ^ HasClock _ ()
 * ```
 *
 * Effectfully sleeps for an arbitrary number of milliseconds
 *
 * @category Combinators
 * @since 1.0.0
 */
export const sleep = (ms: number): Effect<HasClock, never, void> => clockSleep(ms);

/**
 * ```haskell
 * supervised :: Effect t => Supervisor _ -> t x r e a -> t x r e a
 * ```
 *
 * Returns an effect with the behavior of this one, but where all child
 * fibers forked in the effect are reported to the specified supervisor.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const supervised = T.supervised;

/**
 * ```haskell
 * _summarized :: Effect t => (t x r e a, t x1 r1 e1 b, ((b, b) -> c)) ->
 *    t (x | x1) (r & r1) (e | e1) [c, a]
 * ```
 *
 * Summarizes a effect by computing some value before and after execution, and
 * then combining the values to produce a summary, together with the result of
 * execution.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _summarized = T._summarized;

/**
 * ```haskell
 * summarized :: Effect t => (t x1 r1 e1 b, ((b, b) -> c)) -> t x r e a ->
 *    t (x | x1) (r & r1) (e | e1) [c, a]
 * ```
 *
 * Summarizes a effect by computing some value before and after execution, and
 * then combining the values to produce a summary, together with the result of
 * execution.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const summarized = T.summarized;

/**
 * ```haskell
 * _delay :: Effect t => (t x r e a, Number) -> t ^ (r & HasClock) e a
 * ```
 *
 * Delays an `Effect` by an arbitrary number of milliseconds
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _delay = <R, E, A>(ef: Effect<R, E, A>, ms: number): Effect<R & HasClock, E, A> =>
   T._chain(sleep(ms), () => ef);

/**
 * ```haskell
 * delay :: Effect t => Number -> t x r e a -> t ^ (r & HasClock) e a
 * ```
 *
 * Delays an `Effect` by an arbitrary number of milliseconds
 *
 * @category Combinators
 * @since 1.0.0
 */
export const delay = (ms: number) => <R, E, A>(ef: Effect<R, E, A>): Effect<R & HasClock, E, A> =>
   _delay(ef, ms);

/**
 * Returns an effect that dies with a `RuntimeError` having the
 * specified message. This method can be used for terminating a fiber
 * because a defect has been detected in the code.
 */
export const dieMessage = (message: string) => T.die(new RuntimeError(message));

/**
 * Imports an asynchronous side-effect into an effect. The effect also
 * returns a canceler, which will be used by the runtime to cancel the
 * asynchronous effect if the fiber executing the effect is interrupted.
 *
 * The list of fibers, that may complete the async callback, is used to
 * provide better diagnostics.
 */
export const asyncInterrupt = T.asyncInterrupt;

/**
 * Imports an asynchronous side-effect into an effect. The side-effect
 * has the option of returning the value synchronously, which is useful in
 * cases where it cannot be determined if the effect is synchronous or
 * asynchronous until the side-effect is actually executed. The effect also
 * has the option of returning a canceler, which will be used by the runtime
 * to cancel the asynchronous effect if the fiber executing the effect is
 * interrupted.
 *
 * If the register function returns a value synchronously, then the callback
 * function must not be called. Otherwise the callback function must be called
 * at most once.
 *
 * The list of fibers, that may complete the async callback, is used to
 * provide better diagnostics.
 */
export const maybeAsyncInterrupt = T.maybeAsyncInterrupt;

/**
 * Returns an effect whose interruption will be disconnected from the
 * fiber's own interruption, being performed in the background without
 * slowing down the fiber's interruption.
 *
 * This method is useful to create "fast interrupting" effects. For
 * example, if you call this on a bracketed effect, then even if the
 * effect is "stuck" in acquire or release, its interruption will return
 * immediately, while the acquire / release are performed in the
 * background.
 *
 * See timeout and race for other applications.
 */
export const disconnect = T.disconnect;

/**
 * Returns an effect whose failure and success have been lifted into an
 * `Either`. The resulting effect cannot fail, because the failure case has
 * been exposed as part of the `Either` success case.
 *
 * This method is useful for recovering from effects that may fail.
 *
 * The error parameter of the returned is `never`, since it is
 * guaranteed the effect does not model failure.
 */
export const either: <R, E, A>(ef: Effect<R, E, A>) => Effect<R, never, Either<E, A>> = T.foldM(
   flow(E.left, T.pure),
   flow(E.right, T.pure)
);

export const ensuring = T.ensuring;

export const eventually = <R, E, A>(ef: Effect<R, E, A>): Effect<R, E, A> =>
   T._orElse(ef, () => eventually(ef));

/**
 * Returns the `FiberID` of the fiber executing the effect that calls this method.
 */
export const checkFiberId = T.checkFiberId;

/**
 * Applies `or` if the predicate fails.
 */
export const _filterOrElse: {
   <R, E, A, B extends A, R1, E1, A1>(
      ef: Effect<R, E, A>,
      refinement: Refinement<A, B>,
      or: (a: A) => Effect<R1, E1, A1>
   ): Effect<R & R1, E | E1, B | A1>;
   <R, E, A, R1, E1, A1>(
      ef: Effect<R, E, A>,
      predicate: Predicate<A>,
      or: (a: A) => Effect<R1, E1, A1>
   ): Effect<R & R1, E | E1, A | A1>;
} = <R, E, A, R1, E1, A1>(
   ef: Effect<R, E, A>,
   predicate: Predicate<A>,
   or: (a: A) => Effect<R1, E1, A1>
): Effect<R & R1, E | E1, A | A1> =>
   T._chain(ef, (a): Effect<R1, E1, A | A1> => (predicate(a) ? T.pure(a) : or(a)));

/**
 * Applies `or` if the predicate fails.
 */
export const filterOrElse: {
   <A, B extends A>(refinement: Refinement<A, B>): <R1, E1, A1>(
      or: (a: A) => Effect<R1, E1, A1>
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R & R1, E | E1, A | A1>;
   <A>(predicate: Predicate<A>): <R1, E1, A1>(
      or: (a: A) => Effect<R1, E1, A1>
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R & R1, E | E1, A | A1>;
} = <A>(predicate: Predicate<A>) => <R1, E1, A1>(or: (a: A) => Effect<R1, E1, A1>) => <X, R, E>(
   ef: Effect<R, E, A>
) => _filterOrElse(ef, predicate, or);

/**
 * Fails with `failWith` if the predicate fails.
 */
export const _filterOrFail: {
   <R, E, A, B extends A, E1>(
      ef: Effect<R, E, A>,
      refinement: Refinement<A, B>,
      failWith: (a: A) => E1
   ): Effect<R, E | E1, B>;
   <R, E, A, E1>(ef: Effect<R, E, A>, predicate: Predicate<A>, failWith: (a: A) => E1): Effect<
      R,
      E | E1,
      A
   >;
} = <R, E, A, E1>(
   ef: Effect<R, E, A>,
   predicate: Predicate<A>,
   failWith: (a: A) => E1
): Effect<R, E | E1, A> => _filterOrElse(ef, predicate, flow(failWith, T.fail));

/**
 * Fails with `failWith` if the predicate fails.
 */
export const filterOrFail: {
   <A, B extends A>(refinement: Refinement<A, B>): <E1>(
      failWith: (a: A) => E1
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R, E | E1, B>;
   <A>(predicate: Predicate<A>): <E1>(
      failWith: (a: A) => E1
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R, E | E1, A>;
} = <A>(predicate: Predicate<A>) => <E1>(failWith: (a: A) => E1) => <R, E>(
   ef: Effect<R, E, A>
): Effect<R, E | E1, A> => _filterOrFail(ef, predicate, failWith);

/**
 * Dies with specified `unknown` if the predicate fails.
 */
export const _filterOrDie: {
   <R, E, A, B extends A>(
      ef: Effect<R, E, A>,
      refinement: Refinement<A, B>,
      dieWith: (a: A) => unknown
   ): Effect<R, E, A>;
   <R, E, A>(ef: Effect<R, E, A>, predicate: Predicate<A>, dieWith: (a: A) => unknown): Effect<
      R,
      E,
      A
   >;
} = <R, E, A>(ef: Effect<R, E, A>, predicate: Predicate<A>, dieWith: (a: A) => unknown) =>
   _filterOrElse(ef, predicate, flow(dieWith, T.die));

/**
 * Dies with specified `unknown` if the predicate fails.
 */
export const filterOrDie: {
   <A, B extends A>(refinement: Refinement<A, B>): (
      dieWith: (a: A) => unknown
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R, E, A>;
   <A>(predicate: Predicate<A>): (
      dieWith: (a: A) => unknown
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R, E, A>;
} = <A>(predicate: Predicate<A>) => (dieWith: (a: A) => unknown) => <R, E>(ef: Effect<R, E, A>) =>
   _filterOrDie(ef, predicate, dieWith);

/**
 * Dies with an [[Error]] having the specified text message
 * if the predicate fails.
 */
export const _filterOrDieMessage: {
   <R, E, A, B extends A>(
      ef: Effect<R, E, A>,
      refinement: Refinement<A, B>,
      message: (a: A) => string
   ): Effect<R, E, A>;
   <R, E, A>(ef: Effect<R, E, A>, predicate: Predicate<A>, message: (a: A) => string): Effect<
      R,
      E,
      A
   >;
} = <R, E, A>(ef: Effect<R, E, A>, predicate: Predicate<A>, message: (a: A) => string) =>
   _filterOrDie(ef, predicate, (a) => new Error(message(a)));

/**
 * Dies with an [[Error]] having the specified text message
 * if the predicate fails.
 */
export const filterOrDieMessage: {
   <A, B extends A>(refinement: Refinement<A, B>): (
      message: (a: A) => string
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R, E, A>;
   <A>(predicate: Predicate<A>): (
      message: (a: A) => string
   ) => <R, E>(ef: Effect<R, E, A>) => Effect<R, E, A>;
} = <A>(predicate: Predicate<A>) => (message: (a: A) => string) => <R, E>(ef: Effect<R, E, A>) =>
   _filterOrDieMessage(ef, predicate, message);

export const firstSuccessOf = <R, E, A>(efs: NonEmptyArray<Effect<R, E, A>>) =>
   A._reduce(NEA.tail(efs), NEA.head(efs), (b, a) => T._orElse(b, () => a));

export const _foldM = T._foldM;

export const foldM = T.foldM;

/**
 * A more powerful version of `_foldM` that allows recovering from any kind of failure except interruptions.
 */
export const _foldCauseM = T._foldCauseM;

/**
 * A more powerful version of `foldM` that allows recovering from any kind of failure except interruptions.
 */
export const foldCauseM = T.foldCauseM;

/**
 * A more powerful version of `_fold` that allows recovering from any kind of failure except interruptions.
 */
export const _foldCause = <R, E, A, A1, A2>(
   ef: Effect<R, E, A>,
   onFailure: (cause: Cause<E>) => A1,
   onSuccess: (a: A) => A2
) => T._foldCauseM(ef, flow(onFailure, T.pure), flow(onSuccess, T.pure));

/**
 * A more powerful version of `fold` that allows recovering from any kind of failure except interruptions.
 */
export const foldCause = <E, A, A1, A2>(
   onFailure: (cause: Cause<E>) => A1,
   onSuccess: (a: A) => A2
) => <R>(ef: Effect<R, E, A>) => _foldCause(ef, onFailure, onSuccess);

/**
 * Folds an Iterable[A] using an effectual function f, working sequentially from left to right.
 */
export const _foldl = T._foldl;

/**
 * Folds an Iterable[A] using an effectual function f, working sequentially from left to right.
 */
export const foldl = T.foldl;

/**
 * Folds an Iterable[A] using an effectual function f, working sequentially from left to right.
 */
export const _foldr = T._foldr;

/**
 * Folds an Iterable[A] using an effectual function f, working sequentially from left to right.
 */
export const foldr = T.foldr;

/**
 * Folds over the failure value or the success value to yield an effect that
 * does not fail, but succeeds with the value returned by the left or right
 * function passed to `fold`.
 */
export const _fold = <R, E, A, A1, A2>(
   ef: Effect<R, E, A>,
   onFailure: (reason: E) => A1,
   onSuccess: (a: A) => A2
): Effect<R, never, A1 | A2> => T._foldM(ef, flow(onFailure, T.pure), flow(onSuccess, T.pure));

/**
 * Folds over the failure value or the success value to yield an effect that
 * does not fail, but succeeds with the value returned by the left or right
 * function passed to `fold`.
 */
export const fold = <E, A, A1, A2>(onFailure: (reason: E) => A1, onSuccess: (a: A) => A2) => <R>(
   ef: Effect<R, E, A>
) => _fold(ef, onFailure, onSuccess);

/**
 * Applies the function `f` to each element of the `Iterable<A>` and
 * returns the results in a new `readonly B[]`.
 *
 * For a parallel version of this method, see `foreachPar`.
 * If you do not need the results, see `foreachUnit` for a more efficient implementation.
 */
export const _foreach = T._foreach;

/**
 * Applies the function `f` to each element of the `Iterable<A>` and
 * returns the results in a new `readonly B[]`.
 *
 * For a parallel version of this method, see `foreachPar`.
 * If you do not need the results, see `foreachUnit` for a more efficient implementation.
 */
export const foreach = T.foreach;

/**
 * Applies the function `f` to each element of the `Iterable<A>` in parallel,
 * and returns the results in a new `readonly B[]`.
 *
 * For a sequential version of this method, see `foreach`.
 */
export const _foreachExec = Par._foreachExec;

/**
 * Applies the function `f` to each element of the `Iterable<A>` in parallel,
 * and returns the results in a new `readonly B[]`.
 *
 * For a sequential version of this method, see `foreach`.
 */
export const foreachExec = Par.foreachExec;

/**
 * Applies the function `f` to each element of the `Iterable<A>` in parallel,
 * and returns the results in a new `readonly B[]`.
 *
 * For a sequential version of this method, see `foreach`.
 */
export const _foreachPar = Par._foreachPar;

/**
 * Applies the function `f` to each element of the `Iterable<A>` in parallel,
 * and returns the results in a new `readonly B[]`.
 *
 * For a sequential version of this method, see `foreach`.
 */
export const foreachPar = Par.foreachPar;

/**
 * Applies the functionw `f` to each element of the `Iterable<A>` in parallel,
 * and returns the results in a new `readonly B[]`.
 *
 * Unlike `foreachPar`, this method will use at most up to `n` fibers.
 */
export const _foreachParN = Par._foreachParN;

/**
 * Applies the functionw `f` to each element of the `Iterable<A>` in parallel,
 * and returns the results in a new `readonly B[]`.
 *
 * Unlike `foreachPar`, this method will use at most up to `n` fibers.
 */
export const foreachParN = Par.foreachParN;

/**
 * Applies the function `f` to each element of the `Iterable<A>` and runs
 * produced effects sequentially.
 *
 * Equivalent to `asUnit(foreach(f)(as))`, but without the cost of building
 * the list of results.
 */
export const _foreachUnit = T._foreachUnit;

/**
 * Applies the function `f` to each element of the `Iterable<A>` and runs
 * produced effects sequentially.
 *
 * Equivalent to `asUnit(foreach(f)(as))`, but without the cost of building
 * the list of results.
 */
export const foreachUnit = T.foreachUnit;

/**
 * Applies the function `f` to each element of the `Iterable<A>` and runs
 * produced effects in parallel, discarding the results.
 *
 * For a sequential version of this method, see `foreach_`.
 *
 * Optimized to avoid keeping full tree of effects, so that method could be
 * able to handle large input sequences.
 * Behaves almost like this code:
 *
 * Additionally, interrupts all effects on any failure.
 */
export const _foreachUnitPar = Par._foreachUnitPar;

/**
 * Applies the function `f` to each element of the `Iterable<A>` and runs
 * produced effects in parallel, discarding the results.
 *
 * For a sequential version of this method, see `foreach_`.
 *
 * Optimized to avoid keeping full tree of effects, so that method could be
 * able to handle large input sequences.
 * Behaves almost like this code:
 *
 * Additionally, interrupts all effects on any failure.
 */
export const foreachUnitPar = Par.foreachUnitPar;

/**
 * Applies the function `f` to each element of the `Iterable[A]` and runs
 * produced effects in parallel, discarding the results.
 *
 * Unlike `foreachPar_`, this method will use at most up to `n` fibers.
 */
export const _foreachUnitParN = Par._foreachUnitParN;

/**
 * Applies the function `f` to each element of the `Iterable[A]` and runs
 * produced effects in parallel, discarding the results.
 *
 * Unlike `foreachPar_`, this method will use at most up to `n` fibers.
 */
export const foreachUnitParN = Par.foreachUnitParN;

/**
 * Repeats this effect forever (until the first failure).
 */
export const forever = <R, E, A>(ef: Effect<R, E, A>): Effect<R, E, A> =>
   T._chain(ef, () => forever(ef));

/**
 * Returns an effect that forks all of the specified values, and returns a
 * composite fiber that produces a list of their results, in order.
 */
export const forkAll = <R, E, A>(
   efs: Iterable<Effect<R, E, A>>
): RIO<R, Fiber.Fiber<E, ReadonlyArray<A>>> =>
   T._map(
      T._foreach(efs, T.fork),
      A.reduce(Fiber.succeed([]) as Fiber.Fiber<E, ReadonlyArray<A>>, (b, a) =>
         Fiber._mapBoth(b, a, (_a, _b) => [..._a, _b])
      )
   );

/**
 * Returns an effect that forks all of the specified values, and returns a
 * composite fiber that produces unit. This version is faster than [[forkAll]]
 * in cases where the results of the forked fibers are not needed.
 */
export const forkAllUnit = <R, E, A>(efs: Iterable<Effect<R, E, A>>) =>
   I.reduce_(efs, T.unit as RIO<R, void>, (b, a) => T._chain(T.fork(a), () => b));

/**
 * Forks the effect into a new independent fiber, with the specified name.
 */
export const _forkAs = <R, E, A>(
   ef: Effect<R, E, A>,
   name: string
): RIO<R, Fiber.FiberContext<E, A>> =>
   T.uninterruptibleMask(({ restore }) =>
      pipe(
         Fiber.fiberName,
         FR.set(Mb.just(name)),
         T.chain(() => T.fork(restore(ef)))
      )
   );

/**
 * Forks the effect into a new independent fiber, with the specified name.
 */
export const forkAs = (name: string) => <R, E, A>(
   ef: Effect<R, E, A>
): RIO<R, Fiber.FiberContext<E, A>> => _forkAs(ef, name);

export class ForkScopeRestore {
   constructor(private scope: Scope<Exit<any, any>>) {}

   readonly restore = <R, E, A>(ef: Effect<R, E, A>): Effect<R, E, A> =>
      new OverrideForkScopeInstruction(ef, Mb.just(this.scope));
}

/**
 * Captures the fork scope, before overriding it with the specified new
 * scope, passing a function that allows restoring the fork scope to
 * what it was originally.
 */
export const forkScopeMask = (newScope: Scope<Exit<any, any>>) => <R, E, A>(
   f: (restore: ForkScopeRestore) => Effect<R, E, A>
) =>
   T.forkScopeWith(
      (scope) => new OverrideForkScopeInstruction(f(new ForkScopeRestore(scope)), Mb.just(newScope))
   );

/**
 * Lifts an `Either` into a `Effect` value.
 */
export const fromEither = <E, A>(f: () => Either<E, A>) =>
   T._chain(T.total(f), E.fold(T.fail, T.pure));

/**
 * Creates a `Effect` value that represents the exit value of the specified
 * fiber.
 */
export const fromFiber = <E, A>(fiber: () => Fiber.Fiber<E, A>): IO<E, A> =>
   T._chain(T.total(fiber), Fiber.join);

/**
 * Creates a `Effect` value that represents the exit value of the specified
 * fiber.
 */
export const fromFiberM = <R, E, A, E1>(
   fiber: Effect<R, E, Fiber.Fiber<E1, A>>
): Effect<R, E | E1, A> => T._chain(fiber, Fiber.join);

/**
 * Lifts an `Option` into a `Effect` but preserves the error as an option in the error channel, making it easier to compose
 * in some scenarios.
 */
export const fromMaybe = <A>(m: () => Maybe<A>): IO<Maybe<never>, A> =>
   T._chain(T.total(m), (ma) => (ma._tag === "Nothing" ? T.fail(Mb.nothing()) : T.pure(ma.value)));

export const getOrFail = <A>(v: () => Maybe<A>): IO<NoSuchElementException, A> =>
   T.suspend(() =>
      Mb._fold(v(), () => T.fail(new NoSuchElementException("Effect.getOrFail")), T.pure)
   );

export const ifM = T.ifM;

/**
 * Returns an effect that is interrupted as if by the specified fiber.
 */
export const interruptAs = T.interruptAs;

/**
 * Returns a new effect that performs the same operations as this effect, but
 * interruptibly, even if composed inside of an uninterruptible region.
 *
 * Note that effects are interruptible by default, so this function only has
 * meaning if used within an uninterruptible region.
 *
 * WARNING: This operator "punches holes" into effects, allowing them to be
 * interrupted in unexpected places. Do not use this operator unless you know
 * exactly what you are doing. Instead, you should use `uninterruptibleMask`.
 */
export const makeInterruptible = T.makeInterruptible;

/**
 * Makes the effect interruptible, but passes it a restore function that
 * can be used to restore the inherited interruptibility from whatever region
 * the effect is composed into.
 */
export const interruptibleMask = <R, E, A>(
   f: (restore: T.InterruptStatusRestore) => Effect<R, E, A>
) => T.checkInterruptible((flag) => T.makeInterruptible(f(new T.InterruptStatusRestoreImpl(flag))));

/**
 * Iterates with the specified effectual function. The moral equivalent of:
 *
 * ```typescript
 * let s = initial;
 *
 * while (cont(s)) {
 *   s = body(s);
 * }
 *
 * return s;
 * ```
 */
export const iterate = <A>(initial: A) => (cont: (b: A) => boolean) => <R, E>(
   body: (b: A) => Effect<R, E, A>
): Effect<R, E, A> =>
   cont(initial) ? T._chain(body(initial), (a1) => iterate(a1)(cont)(body)) : T.pure(initial);

/**
 * ```haskell
 * just :: Effect t => T x r e (Maybe a) -> T x r (Maybe e) a
 * ```
 *
 * Converts an optional value into an optional error
 *
 * @category Combinators
 * @since 1.0.0
 */
export const just: <R, E, A>(ef: Effect<R, E, Maybe<A>>) => Effect<R, Maybe<E>, A> = T.foldM(
   (e) => T.fail(Mb.just(e)),
   Mb.fold(() => fail(Mb.nothing), T.pure)
);

/**
 * ```haskell
 * _justOrElse :: Effect t => (t x r e (Maybe a), (() -> b)) -> t x r e (a | b)
 * ```
 *
 * Extracts the optional value, or returns the given 'orElse'.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _justOrElse = <R, E, A, B>(
   ef: Effect<R, E, Maybe<A>>,
   orElse: Lazy<B>
): Effect<R, E, A | B> => pipe(ef, T.map(Mb.getOrElse(orElse)));

/**
 * ```haskell
 * justOrElse :: Effect t => (() -> b) -> t x r e (Maybe a) -> t x r e (a | b)
 * ```
 *
 * Extracts the optional value, or returns the given 'orElse'.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const justOrElse = <B>(orElse: Lazy<B>) => <R, E, A>(ef: Effect<R, E, Maybe<A>>) =>
   _justOrElse(ef, orElse);

/**
 * ```haskell
 * _justOrElseM :: Effect t => (t x r e (Maybe a), t x1 r1 e1 b) ->
 *    t (x | x1) (r & r1) (e | e1) (a | b)
 * ```
 *
 * Extracts the optional value, or executes the effect 'orElse'.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _justOrElseM = <R, E, A, R1, E1, B>(
   ef: Effect<R, E, Maybe<A>>,
   orElse: Effect<R1, E1, B>
): Effect<R & R1, E | E1, A | B> =>
   T._chain(ef as Effect<R, E, Maybe<A | B>>, flow(Mb.map(T.pure), Mb.getOrElse(constant(orElse))));

/**
 * ```haskell
 * _justOrElseM :: Effect t => t x1 r1 e1 b -> t x r e (Maybe a) ->
 *    t (x | x1) (r & r1) (e | e1) (a | b)
 * ```
 *
 * Extracts the optional value, or executes the effect 'orElse'.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const justOrElseM = <R1, E1, B>(orElse: Effect<R1, E1, B>) => <R, E, A>(
   ef: Effect<R, E, Maybe<A>>
): Effect<R & R1, E | E1, A | B> => _justOrElseM(ef, orElse);

/**
 *  Returns an effect with the value on the left part.
 */
export const left = <A>(a: () => A): UIO<Either<A, never>> =>
   T._chain(T.total(a), flow(E.left, T.pure));

/**
 * Loops with the specified effectual function, collecting the results into a
 * list. The moral equivalent of:
 *
 * ```typescript
 * let s  = initial
 * let as = [] as readonly A[]
 *
 * while (cont(s)) {
 *   as = [body(s), ...as]
 *   s  = inc(s)
 * }
 *
 * A.reverse(as)
 * ```
 */
export const loop = <B>(initial: B) => (cont: (a: B) => boolean, inc: (b: B) => B) => <R, E, A>(
   body: (b: B) => Effect<R, E, A>
): Effect<R, E, ReadonlyArray<A>> =>
   cont(initial)
      ? T._chain(body(initial), (a) =>
           pipe(
              loop(inc(initial))(cont, inc)(body),
              T.map((as) => [a, ...as])
           )
        )
      : T.pure([]);

/**
 * Loops with the specified effectual function purely for its effects. The
 * moral equivalent of:
 *
 * ```
 * var s = initial
 *
 * while (cont(s)) {
 *   body(s)
 *   s = inc(s)
 * }
 * ```
 */
export const loopUnit = <A>(initial: A) => (cont: (a: A) => boolean, inc: (a: A) => A) => <R, E>(
   body: (a: A) => Effect<R, E, any>
): Effect<R, E, void> =>
   cont(initial) ? T._chain(body(initial), () => loop(inc(initial))(cont, inc)(body)) : T.unit;

/**
 * Returns a memoized version of the specified effectual function.
 */
export const memoize = <R, E, A, B>(f: (a: A) => Effect<R, E, B>): UIO<(a: A) => Effect<R, E, B>> =>
   pipe(
      XRM.makeRefM(new Map<A, XP.XPromise<E, B>>()),
      T.map((ref) => (a: A) =>
         pipe(
            T.of,
            T.bindS("promise", () =>
               pipe(
                  ref,
                  XRM.modify((m) => {
                     const memo = m.get(a);
                     return memo
                        ? T.pure(tuple(memo, m))
                        : pipe(
                             T.of,
                             T.bindS("promise", () => XP.make<E, B>()),
                             T.tap(({ promise }) => T.fork(T.to(promise)(f(a)))),
                             T.map(({ promise }) => tuple(promise, m.set(a, promise)))
                          );
                  })
               )
            ),
            T.bindS("b", ({ promise }) => XP.wait(promise)),
            T.map(({ b }) => b)
         )
      )
   );

/**
 * Returns a memoized version of the specified effectual function.
 *
 * This variant uses the compare function to compare `A`
 */
export const memoizeEq = <A>(eq: Eq<A>) => <R, E, B>(
   f: (a: A) => Effect<R, E, B>
): UIO<(a: A) => Effect<R, E, B>> =>
   pipe(
      XRM.makeRefM(new Map<A, XP.XPromise<E, B>>()),
      T.map((ref) => (a: A) =>
         pipe(
            T.of,
            T.bindS("promise", () =>
               pipe(
                  ref,
                  XRM.modify((m) => {
                     for (const [k, v] of Array.from(m)) {
                        if (eq.equals(k)(a)) {
                           return T.pure(tuple(v, m));
                        }
                     }
                     return pipe(
                        T.of,
                        T.bindS("promise", () => XP.make<E, B>()),
                        T.tap(({ promise }) => T.fork(T.to(promise)(f(a)))),
                        T.map(({ promise }) => tuple(promise, m.set(a, promise)))
                     );
                  })
               )
            ),
            T.bindS("b", ({ promise }) => XP.wait(promise)),
            T.map(({ b }) => b)
         )
      )
   );

/**
 * Merges an `Iterable[IO]` to a single IO, working sequentially.
 */
export const mergeAll = <B>(zero: B) => <A>(f: (b: B, a: A) => B) => <R, E>(
   as: Iterable<Effect<R, E, A>>
): Effect<R, E, B> => I.reduce_(as, T.pure(zero) as Effect<R, E, B>, (b, a) => T._mapBoth(b, a, f));

/**
 * Merges an `Iterable[IO]` to a single IO, working in parallel.
 *
 * Due to the parallel nature of this combinator, `f` must be both:
 * - commutative: `f(a, b) == f(b, a)`
 * - associative: `f(a, f(b, c)) == f(f(a, b), c)`
 *
 * It's unsafe to execute side effects inside `f`, as `f` may be executed
 * more than once for some of `in` elements during effect execution.
 */
export const mergeAllPar = <B>(zero: B) => <A>(f: (b: B, a: A) => B) => <R, E>(
   as: Iterable<Effect<R, E, A>>
): Effect<R, E, B> =>
   I.reduce_(as, T.pure(zero) as Effect<R, E, B>, (b, a) => Par._bothMapPar(b, a, f));

/**
 * Merges an `Iterable[IO]` to a single IO, working in with up to `n` fibers in parallel.
 *
 * Due to the parallel nature of this combinator, `f` must be both:
 * - commutative: `f(a, b) == f(b, a)`
 * - associative: `f(a, f(b, c)) == f(f(a, b), c)`
 *
 * It's unsafe to execute side effects inside `f`, as `f` may be executed
 * more than once for some of `in` elements during effect execution.
 */
export const mergeAllParN = (n: number) => <B>(zero: B) => <A>(f: (b: B, a: A) => B) => <R, E>(
   as: Iterable<Effect<R, E, A>>
): Effect<R, E, B> =>
   T._chain(XR.makeRef(zero), (acc) =>
      T._chain(
         Par._foreachUnitParN(n)(
            as,
            T.chain((a) =>
               pipe(
                  acc,
                  XR.update((b) => f(b, a))
               )
            )
         ),
         () => acc.get
      )
   );


export const _onExit = T.onExit_;

export const onExit = T.onExit;

export const onError = T.onError;

export const _onInterrupt = T._onInterrupt;

export const onInterrupt = <R1>(
   cleanup: (interruptors: ReadonlySet<FiberId>) => Effect<R1, never, any>
) => <R, E, A>(ef: Effect<R, E, A>) => T._onInterrupt(ef, cleanup);

export const _onInterruptExtended = T._onInterruptExtended;


/**
 * Keeps none of the errors, and terminates the fiber with them, using
 * the specified function to convert the `E` into a `unknown`.
 */
export const orDie = T.orDie;

/**
 * Converts all failures to unchecked exceptions
 */
export const orDieKeep = T.orDieKeep;

/**
 * Keeps none of the errors, and terminates the fiber with them, using
 * the specified function to convert the `E` into a `unknown`.
 */
export const _orDieWith = T._orDieWith;

/**
 * Keeps none of the errors, and terminates the fiber with them, using
 * the specified function to convert the `E` into a `unknown`.
 */
export const orDieWith = T.orDieWith;

/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise executes the specified effect.
 */
export const _orElse = T._orElse;

/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise executes the specified effect.
 */
export const orElse = T.orElse;

/**
 * Returns an effect that will produce the value of this effect, unless it
 * fails, in which case, it will produce the value of the specified effect.
 */
export const _orElseEither = T._orElseEither;

/**
 * Returns an effect that will produce the value of this effect, unless it
 * fails, in which case, it will produce the value of the specified effect.
 */
export const orElseEither = T.orElseEither;

/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise fails with the specified error.
 */
export const _orElseFail = T._orElseFail;

/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise fails with the specified error.
 */
export const orElseFail = <E1>(e: E1) => <R, E, A>(ef: Effect<R, E, A>) => _orElseFail(ef, e);

/**
 * Returns an effect that will produce the value of this effect, unless it
 * fails with the `None` value, in which case it will produce the value of
 * the specified effect.
 */
export const _orElseMaybe = T._orElseMaybe;

/**
 * Returns an effect that will produce the value of this effect, unless it
 * fails with the `None` value, in which case it will produce the value of
 * the specified effect.
 */
export const orElseMaybe = T.orElseMaybe;

/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise succeeds with the specified value.
 */
export const _orElseSucceed = T._orElseSucceed;

/**
 * Executes this effect and returns its value, if it succeeds, but
 * otherwise succeeds with the specified value.
 */
export const orElseSucceed = T.orElseSucceed;

/**
 * Feeds elements of type `A` to a function `f` that returns an effect.
 * Collects all successes and failures in a separated fashion.
 */
export const partitionI = <R, E, A, B>(f: (a: A) => Effect<R, E, B>) => (
   as: Iterable<A>
): Effect<R, never, Separated<Iterable<E>, Iterable<B>>> =>
   T._map(
      T._foreach(as, (a) => T.either(f(a))),
      I.partitionMap(identity)
   );

/**
 * Feeds elements of type `A` to a function `f` that returns an effect.
 * Collects all successes and failures in parallel and returns the result as
 * a tuple.
 */
export const partitionParI = <R, E, A, B>(f: (a: A) => Effect<R, E, B>) => (
   as: Iterable<A>
): Effect<R, never, Separated<Iterable<E>, Iterable<B>>> =>
   T._map(
      Par._foreachPar(as, (a) => T.either(f(a))),
      I.partitionMap(identity)
   );

/**
 * Feeds elements of type `A` to a function `f` that returns an effect.
 * Collects all successes and failures in parallel and returns the result as
 * a tuple.
 *
 * Unlike `partitionPar`, this method will use at most up to `n` fibers.
 */
export const partitionParNI = (n: number) => <R, E, A, B>(f: (a: A) => Effect<R, E, B>) => (
   as: Iterable<A>
): Effect<R, never, Separated<Iterable<E>, Iterable<B>>> =>
   T._map(
      Par._foreachParN(n)(as, (a) => T.either(f(a))),
      I.partitionMap(identity)
   );

/**
 * Create an Effect that when executed will construct `promise` and wait for its result,
 * errors will be handled using `onReject`
 */
export const _fromPromiseWith = <E, A>(
   promise: Lazy<Promise<A>>,
   onReject: (reason: unknown) => E
): IO<E, A> =>
   T.async((resolve) => {
      promise().then(flow(T.pure, resolve)).catch(flow(onReject, T.fail, resolve));
   });

/**
 * Create an Effect that when executed will construct `promise` and wait for its result,
 * errors will be handled using `onReject`
 */
export const fromPromiseWith = <E>(onReject: (reason: unknown) => E) => <A>(
   promise: Lazy<Promise<A>>
): IO<E, A> => _fromPromiseWith(promise, onReject);

/**
 * Create an Effect that when executed will construct `promise` and wait for its result,
 * errors will produce failure as `unknown`
 */
export const fromPromise = <A>(promise: Lazy<Promise<A>>): IO<unknown, A> =>
   T.async((resolve) => {
      promise().then(flow(T.pure, resolve)).catch(flow(T.fail, resolve));
   });

/**
 * Like fromPromise but produces a defect in case of errors
 */
export const fromPromiseDie = <A>(promise: Lazy<Promise<A>>): UIO<A> =>
   T.async((resolve) => {
      promise().then(flow(T.pure, resolve)).catch(flow(T.die, resolve));
   });

/**
 * Provides a layer to the given effect
 */
export const _provideSomeLayer = <R, E, A, R1, E1, A1>(
   ef: Effect<R & A1, E, A>,
   layer: L.Layer<R1, E1, A1>
): Effect<R & R1, E | E1, A> =>
   M._use(layer.build, (p) => T._provideSome(ef, (r: R & R1) => ({ ...r, ...p })));

/**
 * Provides a layer to the given effect
 */
export const provideSomeLayer = <R1, E1, A1>(layer: L.Layer<R1, E1, A1>) => <R, E, A>(
   ef: Effect<R & A1, E, A>
): Effect<R & R1, E | E1, A> =>
   M._use(layer.build, (p) => T._provideSome(ef, (r: R & R1) => ({ ...r, ...p })));

const mergeInterruption = <E1, A, A1>(a: A) => (x: Exit<E1, A1>): Effect<unknown, E1, A> => {
   switch (x._tag) {
      case "Success":
         return T.pure(a);
      case "Failure":
         return C.interruptedOnly(x.cause) ? T.pure(a) : T.halt(x.cause);
   }
};

/**
 * Returns an effect that races this effect with the specified effect,
 * returning the first successful `A` from the faster side. If one effect
 * succeeds, the other will be interrupted. If neither succeeds, then the
 * effect will fail with some error.
 *
 * WARNING: The raced effect will safely interrupt the "loser", but will not
 * resume until the loser has been cleanly terminated.
 */
export const _race = <R, E, A, R1, E1, A1>(
   ef: Effect<R, E, A>,
   that: Effect<R1, E1, A1>
): Effect<R & R1, E | E1, A | A1> =>
   T.checkDescriptor((d) =>
      T.raceWith(
         ef,
         that,
         (exit, right) =>
            Ex._foldM(
               exit,
               (cause) => _mapErrorCause(Fiber.join(right), (_) => C.both(cause, _)),
               (a) => T._chain(right.interruptAs(d.id), mergeInterruption(a))
            ),
         (exit, left) =>
            Ex._foldM(
               exit,
               (cause) => _mapErrorCause(Fiber.join(left), (_) => C.both(cause, _)),
               (a) => T._chain(left.interruptAs(d.id), mergeInterruption(a))
            )
      )
   );

/**
 * Returns an effect that races this effect with the specified effect,
 * returning the first successful `A` from the faster side. If one effect
 * succeeds, the other will be interrupted. If neither succeeds, then the
 * effect will fail with some error.
 *
 * WARNING: The raced effect will safely interrupt the "loser", but will not
 * resume until the loser has been cleanly terminated.
 */
export const race = <R1, E1, A1>(that: Effect<R1, E1, A1>) => <R, E, A>(ef: Effect<R, E, A>) =>
   _race(ef, that);

/**
 * Returns an effect that races this effect with the specified effect,
 * yielding the first result to succeed. If neither effect succeeds, then the
 * composed effect will fail with some error.
 *
 * WARNING: The raced effect will safely interrupt the "loser", but will not
 * resume until the loser has been cleanly terminated.
 */
export const _raceEither = <R, E, A, R1, E1, A1>(
   ef: Effect<R, E, A>,
   that: Effect<R1, E1, A1>
): Effect<R & R1, E | E1, Either<A, A1>> => _race(T._map(ef, E.left), T._map(that, E.right));

/**
 * Returns an effect that races this effect with the specified effect,
 * yielding the first result to succeed. If neither effect succeeds, then the
 * composed effect will fail with some error.
 *
 * WARNING: The raced effect will safely interrupt the "loser", but will not
 * resume until the loser has been cleanly terminated.
 */
export const raceEither = <R1, E1, A1>(that: Effect<R1, E1, A1>) => <R, E, A>(
   ef: Effect<R, E, A>
) => _raceEither(ef, that);

/**
 * Returns an effect that races this effect with the specified effect,
 * yielding the first result to complete, whether by success or failure. If
 * neither effect completes, then the composed effect will not complete.
 *
 * WARNING: The raced effect will safely interrupt the "loser", but will not
 * resume until the loser has been cleanly terminated. If early return is
 * desired, then instead of performing `l raceFirst r`, perform
 * `l.disconnect raceFirst r.disconnect`, which disconnects left and right
 * interrupt signal, allowing a fast return, with interruption performed
 * in the background.
 */
export const raceFirst = <R1, E1, A1>(that: Effect<R1, E1, A1>) => <R, E, A>(
   ef: Effect<R, E, A>
): Effect<R & R1, E | E1, A | A1> =>
   pipe(
      _race(T.result(ef), T.result(that)),
      T.chain((a) => T.done(a as Exit<E | E1, A | A1>))
   );

const arbiter = <E, A>(
   fibers: ReadonlyArray<Fiber.Fiber<E, A>>,
   winner: Fiber.Fiber<E, A>,
   promise: XP.XPromise<E, readonly [A, Fiber.Fiber<E, A>]>,
   fails: XR.Ref<number>
) => (res: Exit<E, A>): UIO<void> =>
   Ex._foldM(
      res,
      (e) =>
         pipe(
            fails,
            XR.modify((c) => tuple(c === 0 ? pipe(promise, XP.halt(e), T.asUnit) : T.unit, c - 1)),
            T.flatten
         ),
      (a) =>
         pipe(
            promise,
            XP.succeed(tuple(a, winner)),
            T.chain((set) =>
               set
                  ? A._reduce(fibers, T.unit as UIO<void>, (io, f) =>
                       f === winner ? io : T._tap(io, () => Fiber.interrupt(f))
                    )
                  : T.unit
            )
         )
   );

/**
 * Returns an effect that races this effect with all the specified effects,
 * yielding the value of the first effect to succeed with a value.
 * Losers of the race will be interrupted immediately.
 *
 * Note: in case of success eventual interruption errors are ignored
 */
export const raceAll = <R, E, A>(
   ios: NonEmptyArray<Effect<R, E, A>>,
   interruptStrategy: "background" | "wait" = "background"
): Effect<R, E, A> =>
   pipe(
      T.of,
      T.bindS("done", () => XP.make<E, readonly [A, Fiber.Fiber<E, A>]>()),
      T.bindS("fails", () => XR.makeRef(ios.length)),
      T.bindS("c", ({ done, fails }) =>
         T.uninterruptibleMask(({ restore }) =>
            pipe(
               T.of,
               T.bindS("fs", () => T._foreach(ios, flow(T.makeInterruptible, T.fork))),
               T.tap(({ fs }) =>
                  A._reduce(fs, T.unit as UIO<void>, (io, f) =>
                     T._chain(io, () => pipe(f.await, T.chain(arbiter(fs, f, done, fails)), T.fork))
                  )
               ),
               T.letS("inheritRefs", () => (res: readonly [A, Fiber.Fiber<E, A>]) =>
                  pipe(res[1].inheritRefs, T.as(res[0]))
               ),
               T.bindS("c", ({ fs, inheritRefs }) =>
                  pipe(
                     restore(pipe(done, XP.wait, T.chain(inheritRefs))),
                     onInterrupt(() =>
                        A._reduce(fs, T.unit as UIO<void>, (io, f) =>
                           T._tap(io, () => Fiber.interrupt(f))
                        )
                     )
                  )
               ),
               T.map(({ c, fs }) => ({ c, fs }))
            )
         )
      ),
      T.tap(({ c: { fs } }) =>
         interruptStrategy === "wait" ? T._foreach(fs, (f) => f.await) : T.unit
      ),
      T.map(({ c: { c } }) => c)
   );

/**
 * ```haskell
 * unsandbox :: Effect t => t x r (Cause e) a -> t x r e a
 * ```
 *
 * The inverse operation `sandbox`
 *
 * @category Combinators
 * @since 1.0.0
 */
export const unsandbox: <R, E, A>(ef: Effect<R, Cause<E>, A>) => Effect<R, E, A> = mapErrorCause(
   C.flatten
);

/**
 * Keeps some of the errors, and terminates the fiber with the rest
 */
export const refineOrDie = <E, E1>(pf: (e: E) => Maybe<E1>) => <R, A>(ef: Effect<R, E, A>) =>
   T._catchAll(ef, (e) =>
      pipe(
         e,
         pf,
         Mb.fold(() => T.die(e), T.fail)
      )
   );

/**
 * Keeps some of the errors, and terminates the fiber with the rest, using
 * the specified function to convert the `E` into a `Throwable`.
 */
export const refineOrDieWith = <E, E1>(pf: (e: E) => Maybe<E1>) => (f: (e: E) => unknown) => <
   X,
   R,
   A
>(
   ef: Effect<R, E, A>
) =>
   T._catchAll(ef, (e) =>
      pipe(
         e,
         pf,
         Mb.fold(() => T.die(f(e)), T.fail)
      )
   );

/**
 * ```haskell
 * _rejectM :: Effect t => (t x r e a, (a -> Maybe t x1 r1 e1 e1)) ->
 *    t (x | x1) (r & r1) (e | e1) a
 * ```
 *
 * Continue with the returned computation if the partial function `pf` matches,
 * translating the successful match into a failure, otherwise continue with
 * the held value.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _rejectM = <R, E, A, R1, E1>(
   ef: Effect<R, E, A>,
   pf: (a: A) => Maybe<Effect<R1, E1, E1>>
): Effect<R & R1, E | E1, A> =>
   T._chain(ef, (a) =>
      Mb._fold(
         pf(a),
         () => T.pure(a),
         (e) => T._chain(e, (e1) => T.fail(e1))
      )
   );

/**
 * ```haskell
 * rejectM :: Effect t => (a -> Maybe t x1 r1 e1 e1) -> t x r e a ->
 *    t (x | x1) (r & r1) (e | e1) a
 * ```
 *
 * Continue with the returned computation if the partial function `pf` matches,
 * translating the successful match into a failure, otherwise continue with
 * the held value.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const rejectM = <R1, E1, A>(pf: (a: A) => Maybe<Effect<R1, E1, E1>>) => <R, E>(
   ef: Effect<R, E, A>
): Effect<R & R1, E | E1, A> => _rejectM(ef, pf);

/**
 * ```haskell
 * _reject :: Effect t => (t x r e a, (a -> Maybe e1)) -> t x r (e | e1) a
 * ```
 *
 * Fail with the returned value if the partial function `pf` matches, otherwise
 * continue with the held value.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _reject = <R, E, A, E1>(
   ef: Effect<R, E, A>,
   pf: (a: A) => Maybe<E1>
): Effect<R, E | E1, A> => _rejectM(ef, (a) => Mb._map(pf(a), T.fail));

/**
 * ```haskell
 * reject :: Effect t => (a -> Maybe e1) -> t x r e a -> t x r (e | e1) a
 * ```
 *
 * Fail with the returned value if the partial function `pf` matches, otherwise
 * continue with the held value.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const reject = <A, E1>(pf: (a: A) => Maybe<E1>) => <R, E>(
   ef: Effect<R, E, A>
): Effect<R, E | E1, A> => _reject(ef, pf);

/**
 * ```haskell
 * _repeatN :: Effect t => (t x r e a, Number) -> t x r e a
 * ```
 *
 * Repeats this effect the specified number of times.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _repeatN = <R, E, A>(ef: Effect<R, E, A>, n: number): Effect<R, E, A> =>
   T._chain(ef, (a) => (n <= 0 ? T.pure(a) : _repeatN(ef, n - 1)));

/**
 * ```haskell
 * repeatN :: Effect t => Number -> t x r e a -> t x r e a
 * ```
 *
 * Repeats this effect the specified number of times.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const repeatN = (n: number) => <R, E, A>(ef: Effect<R, E, A>) => _repeatN(ef, n);

/**
 * ```haskell
 * _repeatOrElseEither :: (Effect t, Schedule s) => (
 *    t x r e a,
 *    s x1 r1 a b,
 *    ((e, Maybe b) -> t x2 r2 e2 c)
 * ) -> t (x | x1 | x2) (r & r1 & r2 & HasClock) e2 (Either c b)
 * ```
 *
 * Returns a new effect that repeats this effect according to the specified
 * schedule or until the first failure, at which point, the failure value
 * and schedule output are passed to the specified handler.
 *
 * Scheduled recurrences are in addition to the first execution, so that
 * `io.repeat(Schedule.once)` yields an effect that executes `io`, and then
 * if that succeeds, executes `io` an additional time.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _repeatOrElseEither = <R, R1, R2, E, E2, A, B, C>(
   ef: Effect<R, E, A>,
   sc: S.Schedule<R1, A, B>,
   f: (_: E, __: Maybe<B>) => Effect<R2, E2, C>
): Effect<R & R1 & R2 & HasClock, E2, Either<C, B>> =>
   pipe(
      S.driver(sc),
      T.chain((driver) => {
         function loop(a: A): Effect<R & R1 & R2 & HasClock, E2, Either<C, B>> {
            return pipe(
               driver.next(a),
               T.foldM(
                  () => pipe(T.orDie(driver.last), T.map(E.right)),
                  (b) =>
                     pipe(
                        ef,
                        T.foldM(
                           (e) => pipe(f(e, Mb.just(b)), T.map(E.left)),
                           (a) => loop(a)
                        )
                     )
               )
            );
         }
         return pipe(
            ef,
            T.foldM(
               (e) => pipe(f(e, Mb.nothing()), T.map(E.left)),
               (a) => loop(a)
            )
         );
      })
   );

/**
 * ```haskell
 * _repeatOrElse :: (Effect t, Schedule s) =>
 *    (t x r e a, s sx sr a b, ((e, Maybe b) -> t x1 r1 e1 c)) ->
 *       t (x | sx | x1) (r & sr & r1 & HasClock) e1 (c | b)
 * ```
 *
 * Returns a new effect that repeats this effect according to the specified
 * schedule or until the first failure, at which point, the failure value
 * and schedule output are passed to the specified handler.
 *
 * Scheduled recurrences are in addition to the first execution, so that
 * `io.repeat(Schedule.once)` yields an effect that executes `io`, and then
 * if that succeeds, executes `io` an additional time.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _repeatOrElse = <R, SR, R1, E, E1, A, B, C>(
   ef: Effect<R, E, A>,
   sc: S.Schedule<SR, A, B>,
   f: (_: E, __: Maybe<B>) => Effect<R1, E1, C>
): Effect<R & SR & R1 & HasClock, E1, C | B> => T._map(_repeatOrElseEither(ef, sc, f), E.merge);

/**
 * ```haskell
 * _repeat :: (Effect t, Schedule s) =>
 *    (t x r e a, s sx sr a b) -> t (x | sx) (r & sr & HasClock) e b
 * ```
 *
 * Returns a new effect that repeats this effect according to the specified
 * schedule or until the first failure. Scheduled recurrences are in addition
 * to the first execution, so that `io.repeat(Schedule.once)` yields an
 * effect that executes `io`, and then if that succeeds, executes `io` an
 * additional time.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _repeat = <R, SR, E, A, B>(
   ef: Effect<R, E, A>,
   sc: S.Schedule<SR, A, B>
): Effect<R & SR & HasClock, E, B> => _repeatOrElse(ef, sc, (e) => T.fail(e));

/**
 * ```haskell
 * repeat :: (Effect t, Schedule s) =>
 *    s sx sr e a -> t x r e a -> t (x | sx) (r & sr & HasClock) e b
 * ```
 *
 * Returns a new effect that repeats this effect according to the specified
 * schedule or until the first failure. Scheduled recurrences are in addition
 * to the first execution, so that `io.repeat(Schedule.once)` yields an
 * effect that executes `io`, and then if that succeeds, executes `io` an
 * additional time.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const repeat = <SR, A, B>(sc: S.Schedule<SR, A, B>) => <R, E>(ef: Effect<R, E, A>) =>
   _repeat(ef, sc);

/**
 * Repeats this effect until its error satisfies the specified effectful predicate.
 */
export const _repeatUntilM = <R, E, A, R1, E1>(
   ef: Effect<R, E, A>,
   f: (a: A) => Effect<R1, E1, boolean>
): Effect<R & R1, E | E1, A> =>
   T._chain(ef, (a) => T._chain(f(a), (b) => (b ? T.pure(a) : _repeatUntilM(ef, f))));

/**
 * Repeats this effect until its result satisfies the specified effectful predicate.
 */
export const repeatUntilM = <A, R1, E1>(f: (a: A) => Effect<R1, E1, boolean>) => <R, E>(
   ef: Effect<R, E, A>
) => _repeatUntilM(ef, f);

/**
 * Repeats this effect until its result satisfies the specified predicate.
 */
export const _repeatUntil = <R, E, A>(ef: Effect<R, E, A>, f: (a: A) => boolean) =>
   _repeatUntilM(ef, (a) => T.pure(f(a)));

/**
 * Repeats this effect until its result satisfies the specified predicate.
 */
export const repeatUntil = <A>(f: (a: A) => boolean) => <R, E>(ef: Effect<R, E, A>) =>
   _repeatUntil(ef, f);

/**
 * Repeats this effect while its error satisfies the specified effectful predicate.
 */
export const _repeatWhileM = <R, E, A, R1, E1>(
   ef: Effect<R, E, A>,
   f: (a: A) => Effect<R1, E1, boolean>
): Effect<R & R1, E | E1, A> =>
   T._chain(ef, (a) => T._chain(f(a), (b) => (b ? _repeatWhileM(ef, f) : T.pure(a))));

/**
 * Repeats this effect while its error satisfies the specified effectful predicate.
 */
export const repeatWhileM = <A, R1, E1>(f: (a: A) => Effect<R1, E1, boolean>) => <R, E>(
   ef: Effect<R, E, A>
) => _repeatWhileM(ef, f);

/**
 * Repeats this effect while its error satisfies the specified predicate.
 */
export const _repeatWhile = <R, E, A>(ef: Effect<R, E, A>, f: (a: A) => boolean) =>
   _repeatWhileM(ef, (a) => T.pure(f(a)));

/**
 * Repeats this effect while its error satisfies the specified predicate.
 */
export const repeatWhile = <A>(f: (a: A) => boolean) => <R, E>(ef: Effect<R, E, A>) =>
   _repeatWhile(ef, f);

/**
 * Returns an effect that semantically runs the effect on a fiber,
 * producing an `Exit` for the completion value of the fiber.
 */
export const result = T.result;

const __loop = <R, E, A, R1, O, R2, E2, A2>(
   ef: Effect<R, E, A>,
   orElse: (e: E, o: O) => Effect<R2, E2, A2>,
   driver: S.ScheduleDriver<R1 & HasClock, E, O>
): Effect<R & R1 & R2 & HasClock, E2, Either<A2, A>> =>
   pipe(
      ef,
      T.map(E.right),
      T.catchAll((e) =>
         pipe(
            driver.next(e),
            T.foldM(
               () =>
                  pipe(
                     driver.last,
                     T.orDie,
                     T.chain((o) => pipe(orElse(e, o), T.map(E.left)))
                  ),
               () => __loop(ef, orElse, driver)
            )
         )
      )
   );

/**
 * Returns an effect that retries this effect with the specified schedule when it fails, until
 * the schedule is done, then both the value produced by the schedule together with the last
 * error are passed to the specified recovery function.
 */
export const _retryOrElseEither = <R, E, A, R1, O, R2, E2, A2>(
   self: Effect<R, E, A>,
   policy: S.Schedule<R1, E, O>,
   orElse: (e: E, o: O) => Effect<R2, E2, A2>
): Effect<R & R1 & R2 & HasClock, E2, E.Either<A2, A>> =>
   pipe(
      policy,
      S.driver,
      T.chain((a) => __loop(self, orElse, a))
   );

/**
 * Returns an effect that retries this effect with the specified schedule when it fails, until
 * the schedule is done, then both the value produced by the schedule together with the last
 * error are passed to the specified recovery function.
 */
export const retryOrElseEither = <E, R1, O, R2, E2, A2>(
   policy: S.Schedule<R1, E, O>,
   orElse: (e: E, o: O) => Effect<R2, E2, A2>
) => <R, A>(ef: Effect<R, E, A>) => _retryOrElseEither(ef, policy, orElse);

/**
 * Retries with the specified schedule, until it fails, and then both the
 * value produced by the schedule together with the last error are passed to
 * the recovery function.
 */
export const _retryOrElse = <R, E, A, R1, O, R2, E2, A2>(
   self: Effect<R, E, A>,
   policy: S.Schedule<R1, E, O>,
   orElse: (e: E, o: O) => Effect<R2, E2, A2>
): Effect<R & R1 & R2 & HasClock, E2, A | A2> =>
   T._map(_retryOrElseEither(self, policy, orElse), E.fold(identity, identity));

/**
 * Retries with the specified schedule, until it fails, and then both the
 * value produced by the schedule together with the last error are passed to
 * the recovery function.
 */
export const retryOrElse = <E, R1, O, R2, E2, A2>(
   policy: S.Schedule<R1, E, O>,
   orElse: (e: E, o: O) => Effect<R2, E2, A2>
) => <R, A>(self: Effect<R, E, A>) => _retryOrElse(self, policy, orElse);

/**
 * Retries with the specified retry policy.
 * Retries are done following the failure of the original `io` (up to a fixed maximum with
 * `once` or `recurs` for example), so that that `io.retry(Schedule.once)` means
 * "execute `io` and in case of failure, try again once".
 */
export const retry_ = <R, E, A, R1, O>(
   self: Effect<R, E, A>,
   policy: S.Schedule<R1, E, O>
): Effect<R & R1 & HasClock, E, A> => _retryOrElse(self, policy, (e, _) => fail(e));

/**
 * Retries with the specified retry policy.
 * Retries are done following the failure of the original `io` (up to a fixed maximum with
 * `once` or `recurs` for example), so that that `io.retry(Schedule.once)` means
 * "execute `io` and in case of failure, try again once".
 */
export const retry = <R1, E, O>(policy: S.Schedule<R1, E, O>) => <R, A>(
   self: Effect<R, E, A>
): Effect<R & R1 & HasClock, E, A> => retry_(self, policy);

/**
 * Retries this effect until its error satisfies the specified effectful predicate.
 */
export const _retryUntilM = <R, E, A, R1, E1>(
   ef: Effect<R, E, A>,
   f: (e: E) => Effect<R1, E1, boolean>
): Effect<R & R1, E | E1, A> =>
   T._catchAll(ef, (e) => T._chain(f(e), (b) => (b ? T.fail(e) : _retryUntilM(ef, f))));

/**
 * Retries this effect until its error satisfies the specified effectful predicate.
 */
export const retryUntilM = <E, R1, E1>(f: (e: E) => Effect<R1, E1, boolean>) => <R, A>(
   ef: Effect<R, E, A>
): Effect<R & R1, E | E1, A> => _retryUntilM(ef, f);

/**
 * Retries this effect until its error satisfies the specified predicate.
 */
export const _retryUntil = <R, E, A>(ef: Effect<R, E, A>, f: (e: E) => boolean) =>
   _retryUntilM(ef, flow(f, T.pure));

/**
 * Retries this effect until its error satisfies the specified effectful predicate.
 */
export const retryUntil = <E>(f: (e: E) => boolean) => <R, A>(ef: Effect<R, E, A>) =>
   _retryUntil(ef, f);

/**
 * Retries this effect while its error satisfies the specified effectful predicate.
 */
export const _retryWhileM = <R, E, A, R1, E1>(
   ef: Effect<R, E, A>,
   f: (e: E) => Effect<R1, E1, boolean>
): Effect<R & R1, E | E1, A> =>
   T._catchAll(ef, (e) => T._chain(f(e), (b) => (b ? _retryWhileM(ef, f) : T.fail(e))));

/**
 * Retries this effect while its error satisfies the specified effectful predicate.
 */
export const retryWhileM = <E, R1, E1>(f: (e: E) => Effect<R1, E1, boolean>) => <R, A>(
   ef: Effect<R, E, A>
) => _retryWhileM(ef, f);

/**
 * Retries this effect while its error satisfies the specified predicate.
 */
export const _retryWhile = <R, E, A>(ef: Effect<R, E, A>, f: (e: E) => boolean) =>
   _retryWhileM(ef, flow(f, T.pure));

/**
 * Retries this effect while its error satisfies the specified predicate.
 */
export const retryWhile = <E>(f: (e: E) => boolean) => <R, A>(ef: Effect<R, E, A>) =>
   _retryWhile(ef, f);

export const sandboxWith = <R, E, A, E1>(
   f: (_: Effect<R, Cause<E>, A>) => Effect<R, Cause<E1>, A>
) => (ef: Effect<R, E, A>) => unsandbox(f(sandbox(ef)));

/**
 * Forks the effect into a new fiber attached to the global scope. Because the
 * new fiber is attached to the global scope, when the fiber executing the
 * returned effect terminates, the forked fiber will continue running.
 */
export const forkDaemon = T.forkDaemon;

/**
 * Returns an effect that forks this effect into its own separate fiber,
 * returning the fiber immediately, without waiting for it to begin
 * executing the effect.
 *
 * The returned fiber can be used to interrupt the forked fiber, await its
 * result, or join the fiber. See `Fiber` for more information.
 *
 * The fiber is forked with interrupt supervision mode, meaning that when the
 * fiber that forks the child exits, the child will be interrupted.
 */
export const forkIn = T.forkIn;

/**
 * Retrieves the scope that will be used to supervise forked effects.
 */
export const forkScopeWith = T.forkScopeWith;

/**
 * Returns an effect that races this effect with the specified effect, calling
 * the specified finisher as soon as one result or the other has been computed.
 */
export const raceWith = T.raceWith;

/**
 * ```haskell
 * _setInterruptStatus :: Effect t => (t x r e a, InterruptStatus) -> t x r e a
 * ```
 *
 * Switches the interrupt status for this effect. If `true` is used, then the
 * effect becomes interruptible (the default), while if `false` is used, then
 * the effect becomes uninterruptible. These changes are compositional, so
 * they only affect regions of the effect.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const _setInterruptStatus = T._setInterruptStatus;

/**
 * ```haskell
 * setInterruptStatus :: Effect t => InterruptStatus -> t x r e a -> t x r e a
 * ```
 *
 * Switches the interrupt status for this effect. If `true` is used, then the
 * effect becomes interruptible (the default), while if `false` is used, then
 * the effect becomes uninterruptible. These changes are compositional, so
 * they only affect regions of the effect.
 *
 * @category Combinators
 * @since 1.0.0
 */
export const setInterruptStatus = T.setInterruptStatus;

/**
 * Returns an effect that effectfully "peeks" at the failure or success of
 * this effect.
 */
export const _tapBoth = <R, E, A, R1, E1, R2, E2>(
   ef: Effect<R, E, A>,
   onFailure: (e: E) => Effect<R1, E1, any>,
   onSuccess: (a: A) => Effect<R2, E2, any>
) =>
   T._foldCauseM(
      ef,
      (c) =>
         E._fold(
            C.failureOrCause(c),
            (e) => T._chain(onFailure(e), () => T.halt(c)),
            (_) => T.halt(c)
         ),
      onSuccess
   );

/**
 * Returns an effect that effectfully "peeks" at the failure or success of
 * this effect.
 */
export const tapBoth = <E, A, R1, E1, R2, E2>(
   onFailure: (e: E) => Effect<R1, E1, any>,
   onSuccess: (a: A) => Effect<R2, E2, any>
) => <R>(ef: Effect<R, E, A>) => _tapBoth(ef, onFailure, onSuccess);

/**
 * Returns an effect that effectfully "peeks" at the cause of the failure of
 * this effect.
 */
export const _tapCause = <R, E, A, R1, E1>(
   ef: Effect<R, E, A>,
   f: (e: Cause<E>) => Effect<R1, E1, any>
) => _foldCauseM(ef, (c) => T._chain(f(c), () => T.halt(c)), T.pure);

/**
 * Returns an effect that effectfully "peeks" at the cause of the failure of
 * this effect.
 */
export const tapCause = <E, R1, E1>(f: (e: Cause<E>) => Effect<R1, E1, any>) => <R, A>(
   ef: Effect<R, E, A>
) => _tapCause(ef, f);

/**
 * Returns an effect that effectfully "peeks" at the failure of this effect.
 */
export const _tapError = <R, E, A, R1, E1>(ef: Effect<R, E, A>, f: (e: E) => Effect<R1, E1, any>) =>
   _foldCauseM(
      ef,
      (c) =>
         E._fold(
            C.failureOrCause(c),
            (e) => T._chain(f(e), () => T.halt(c)),
            (_) => T.halt(c)
         ),
      T.pure
   );

/**
 * Returns an effect that effectfully "peeks" at the failure of this effect.
 */
export const tapError = <E, R1, E1>(f: (e: E) => Effect<R1, E1, any>) => <R, A>(
   ef: Effect<R, E, A>
) => _tapError(ef, f);

/**
 * A more powerful variation of `timed` that allows specifying the clock.
 */
export const _timedWith = <R, E, A, R1, E1>(ef: Effect<R, E, A>, msTime: Effect<R1, E1, number>) =>
   _summarized(ef, msTime, (start, end) => end - start);

/**
 * A more powerful variation of `timed` that allows specifying the clock.
 */
export const timedWith = <R1, E1>(msTime: Effect<R1, E1, number>) => <R, E, A>(
   ef: Effect<R, E, A>
) => _timedWith(ef, msTime);

/**
 * Returns a new effect that executes this one and times the execution.
 */
export const time = <R, E, A>(ef: Effect<R, E, A>) => _timedWith(ef, currentTime);

/**
 * Returns an effect that will timeout this effect, returning either the
 * default value if the timeout elapses before the effect has produced a
 * value; and or returning the result of applying the function `f` to the
 * success value of the effect.
 *
 * If the timeout elapses without producing a value, the running effect
 * will be safely interrupted
 */
export const _timeoutTo = <R, E, A, B, B1>(
   ef: Effect<R, E, A>,
   d: number,
   b: B,
   f: (a: A) => B1
): Effect<R & HasClock, E, B | B1> =>
   pipe(ef, T.map(f), raceFirst(pipe(sleep(d), T.makeInterruptible, T.as(b))));

/**
 * Returns an effect that will timeout this effect, returning either the
 * default value if the timeout elapses before the effect has produced a
 * value; and or returning the result of applying the function `f` to the
 * success value of the effect.
 *
 * If the timeout elapses without producing a value, the running effect
 * will be safely interrupted
 */
export const timeoutTo = <A, B, B1>(d: number, b: B, f: (a: A) => B1) => <R, E>(
   ef: Effect<R, E, A>
) => _timeoutTo(ef, d, b, f);

/**
 * Returns an effect that will timeout this effect, returning `None` if the
 * timeout elapses before the effect has produced a value; and returning
 * `Some` of the produced value otherwise.
 *
 * If the timeout elapses without producing a value, the running effect
 * will be safely interrupted.
 *
 * WARNING: The effect returned by this method will not itself return until
 * the underlying effect is actually interrupted. This leads to more
 * predictable resource utilization. If early return is desired, then
 * instead of using `timeout(d)(effect)`, use `disconnect(timeout(d)(effect))`,
 * which first disconnects the effect's interruption signal before performing
 * the timeout, resulting in earliest possible return, before an underlying
 * effect has been successfully interrupted.
 */
export const _timeout = <R, E, A>(ef: Effect<R, E, A>, d: number) =>
   _timeoutTo(ef, d, Mb.nothing(), Mb.just);

/**
 * Returns an effect that will timeout this effect, returning `None` if the
 * timeout elapses before the effect has produced a value; and returning
 * `Some` of the produced value otherwise.
 *
 * If the timeout elapses without producing a value, the running effect
 * will be safely interrupted.
 *
 * WARNING: The effect returned by this method will not itself return until
 * the underlying effect is actually interrupted. This leads to more
 * predictable resource utilization. If early return is desired, then
 * instead of using `timeout(d)(effect)`, use `disconnect(timeout(d)(effect))`,
 * which first disconnects the effect's interruption signal before performing
 * the timeout, resulting in earliest possible return, before an underlying
 * effect has been successfully interrupted.
 */
export const timeout = (d: number) => <R, E, A>(ef: Effect<R, E, A>) => _timeout(ef, d);

/**
 * The same as `timeout`, but instead of producing a `None` in the event
 * of timeout, it will produce the specified error.
 */
export const _timeoutFail = <R, E, A, E1>(
   ef: Effect<R, E, A>,
   d: number,
   e: () => E1
): Effect<R & HasClock, E | E1, A> =>
   T.flatten(
      _timeoutTo(
         ef,
         d,
         T.suspend(() => T.fail(e())),
         T.pure
      )
   );

/**
 * The same as `timeout`, but instead of producing a `None` in the event
 * of timeout, it will produce the specified error.
 */
export const timeoutFail = <E1>(d: number, e: () => E1) => <R, E, A>(ef: Effect<R, E, A>) =>
   _timeoutFail(ef, d, e);

/**
 * Returns an effect that keeps or breaks a promise based on the result of
 * this effect. Synchronizes interruption, so if this effect is interrupted,
 * the specified promise will be interrupted, too.
 */
export const to = T.to;

/**
 * Constructs a layer from this effect.
 */
export const toLayerRaw = L.fromRawEffect;

/**
 * Constructs a layer from this effect.
 */
export const toLayer = L.fromEffect;

export const toManaged = <R = unknown, A = unknown>(release?: (a: A) => Effect<R, never, any>) => <
   R1,
   E1,
   A1 extends A
>(
   ef: Effect<R1, E1, A1>
): Managed<R & R1, E1, A1> => (release ? M._makeExit(ef, (a) => release(a)) : M.fromEffect(ef));

/**
 * Transplants specified effects so that when those effects fork other
 * effects, the forked effects will be governed by the scope of the
 * fiber that executes this effect.
 *
 * This can be used to "graft" deep grandchildren onto a higher-level
 * scope, effectively extending their lifespans into the parent scope.
 */
export const transplant = T.transplant;

/**
 * Executed `that` in case `self` fails with a `Cause` that doesn't contain defects,
 * executes `success` in case of successes
 */
export const _tryOrElse = T._tryOrElse;

/**
 * Executed `that` in case `self` fails with a `Cause` that doesn't contain defects,
 * executes `success` in case of successes
 */
export const tryOrElse = T.tryOrElse;

/**
 * When this effect succeeds with a cause, then this method returns a new
 * effect that either fails with the cause that this effect succeeded with,
 * or succeeds with unit, depending on whether the cause is empty.
 *
 * This operation is the opposite of `cause`.
 */
export const uncause = T.uncause;

/**
 * Performs this effect uninterruptibly. This will prevent the effect from
 * being terminated externally, but the effect may fail for internal reasons
 * (e.g. an uncaught error) or terminate due to defect.
 *
 * Uninterruptible effects may recover from all failure causes (including
 * interruption of an inner effect that has been made interruptible).
 */
export const makeUninterruptible = T.makeUninterruptible;

export { InterruptStatusRestoreImpl } from "../Common/effect-base";

/**
 * Makes the effect uninterruptible, but passes it a restore function that
 * can be used to restore the inherited interruptibility from whatever region
 * the effect is composed into.
 */
export const uninterruptibleMask = T.uninterruptibleMask;

const mergeExits = <E, B>() => (
   exits: ReadonlyArray<Either<E, B>>
): Either<NonEmptyArray<E>, Array<B>> => {
   const errors = [] as E[];
   const results = [] as B[];

   exits.forEach((e) => {
      if (e._tag === "Left") {
         errors.push(e.left);
      } else {
         results.push(e.right);
      }
   });

   return A.isNonEmpty(errors) ? E.left(errors) : E.right(results);
};

/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost.
 */
export const _validate = <A, R, E, B>(as: Iterable<A>, f: (a: A) => Effect<R, E, B>) =>
   T.absolve(
      T._map(
         T._foreach(as, (a) => T.either(f(a))),
         mergeExits<E, B>()
      )
   );

export const validate = <A, R, E, B>(f: (a: A) => Effect<R, E, B>) => (as: Iterable<A>) =>
   _validate(as, f);

/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost.
 */
export const _validatePar = <A, R, E, B>(as: Iterable<A>, f: (a: A) => Effect<R, E, B>) =>
   T.absolve(
      T._map(
         Par._foreachPar(as, (a) => T.either(f(a))),
         mergeExits<E, B>()
      )
   );

export const validatePar = <A, R, E, B>(f: (a: A) => Effect<R, E, B>) => (as: Iterable<A>) =>
   _validatePar(as, f);

/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost.
 */
export const _validateParN = (n: number) => <A, R, E, B>(
   as: Iterable<A>,
   f: (a: A) => Effect<R, E, B>
) =>
   T.absolve(
      T._map(
         Par._foreachParN(n)(as, (a) => T.either(f(a))),
         mergeExits<E, B>()
      )
   );

export const validateParN = (n: number) => <A, R, E, B>(f: (a: A) => Effect<R, E, B>) => (
   as: Iterable<A>
) => _validateParN(n)(as, f);

/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost.
 */
export const _validateExec: {
   <R, E, A, B>(es: Sequential, as: Iterable<A>, f: (a: A) => Effect<R, E, B>): Effect<
      R,
      NonEmptyArray<E>,
      ReadonlyArray<B>
   >;
   <R, E, A, B>(es: Parallel, as: Iterable<A>, f: (a: A) => Effect<R, E, B>): Effect<
      R,
      NonEmptyArray<E>,
      ReadonlyArray<B>
   >;
   <R, E, A, B>(es: ParallelN, as: Iterable<A>, f: (a: A) => Effect<R, E, B>): Effect<
      R,
      NonEmptyArray<E>,
      ReadonlyArray<B>
   >;
   <R, E, A, B>(es: ExecutionStrategy, as: Iterable<A>, f: (a: A) => Effect<R, E, B>): Effect<
      R,
      NonEmptyArray<E>,
      ReadonlyArray<B>
   >;
} = <R, E, A, B>(es: ExecutionStrategy, as: Iterable<A>, f: (a: A) => Effect<R, E, B>) =>
   T.absolve(
      T._map(
         Par._foreachExec(es, as, (a) => T.either(f(a))),
         mergeExits<E, B>()
      )
   );

/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost.
 */
export const validateExec: {
   (es: Sequential): <R, E, A, B>(
      f: (a: A) => Effect<R, E, B>
   ) => (as: Iterable<A>) => Effect<R, NonEmptyArray<E>, ReadonlyArray<B>>;
   (es: Parallel): <R, E, A, B>(
      f: (a: A) => Effect<R, E, B>
   ) => (as: Iterable<A>) => Effect<R, NonEmptyArray<E>, ReadonlyArray<B>>;
   (es: ParallelN): <R, E, A, B>(
      f: (a: A) => Effect<R, E, B>
   ) => (as: Iterable<A>) => Effect<R, NonEmptyArray<E>, ReadonlyArray<B>>;
   (es: ExecutionStrategy): <R, E, A, B>(
      f: (a: A) => Effect<R, E, B>
   ) => (as: Iterable<A>) => Effect<R, NonEmptyArray<E>, ReadonlyArray<B>>;
} = (es: ExecutionStrategy) => <R, E, A, B>(f: (a: A) => Effect<R, E, B>) => (as: Iterable<A>) =>
   _validateExec(es, as, f) as any;

export const _whenM = T._whenM;

export const whenM = T.whenM;
