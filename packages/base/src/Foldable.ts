import type { Monoid } from "./Monoid";

import * as HKT from "./HKT";

export interface Foldable<F extends HKT.URIS, C = HKT.Auto> extends HKT.Base<F, C> {
  readonly foldLeft_: FoldLeftFn_<F, C>;
  readonly foldLeft: FoldLeftFn<F, C>;
  readonly foldMap_: FoldMapFn_<F, C>;
  readonly foldMap: FoldMapFn<F, C>;
  readonly foldRight_: FoldRightFn_<F, C>;
  readonly foldRight: FoldRightFn<F, C>;
}

export interface FoldableComposition<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> extends HKT.CompositionBase2<F, G, CF, CG> {
  readonly foldLeft_: FoldLeftFnComposition_<F, G, CF, CG>;
  readonly foldLeft: FoldLeftFnComposition<F, G, CF, CG>;
  readonly foldMap_: FoldMapFnComposition_<F, G, CF, CG>;
  readonly foldMap: FoldMapFnComposition<F, G, CF, CG>;
  readonly foldRight_: FoldRightFnComposition_<F, G, CF, CG>;
  readonly foldRight: FoldRightFnComposition<F, G, CF, CG>;
}

export function getFoldableComposition<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
>(F: Foldable<F, CF>, G: Foldable<G, CG>): FoldableComposition<F, G, CF, CG>;
export function getFoldableComposition<F, G>(
  F: Foldable<HKT.UHKT<F>>,
  G: Foldable<HKT.UHKT<G>>
): FoldableComposition<HKT.UHKT<F>, HKT.UHKT<G>> {
  const foldMap_: FoldMapFnComposition_<HKT.UHKT<F>, HKT.UHKT<G>> = (M) => (fga, f) =>
    F.foldMap_(M)(fga, (ga) => G.foldMap_(M)(ga, f));
  const foldLeft_: FoldLeftFnComposition_<HKT.UHKT<F>, HKT.UHKT<G>> = (fga, b, f) =>
    F.foldLeft_(fga, b, (b, ga) => G.foldLeft_(ga, b, f));
  const foldRight_: FoldRightFnComposition_<HKT.UHKT<F>, HKT.UHKT<G>> = (fga, b, f) =>
    F.foldRight_(fga, b, (ga, b) => G.foldRight_(ga, b, f));

  return HKT.instance<FoldableComposition<HKT.UHKT<F>, HKT.UHKT<G>>>({
    foldLeft_,
    foldMap_,
    foldRight_,
    foldLeft: (b, f) => (fga) => foldLeft_(fga, b, f),
    foldMap: (M) => (f) => (fga) => foldMap_(M)(fga, f),
    foldRight: (b, f) => (fga) => foldRight_(fga, b, f)
  });
}

export interface FoldLeftFn<F extends HKT.URIS, C = HKT.Auto> {
  <A, B>(b: B, f: (b: B, a: A) => B): <N extends string, K, Q, W, X, I, S, R, E>(
    fa: HKT.Kind<F, C, N, K, Q, W, X, I, S, R, E, A>
  ) => B;
}

export interface FoldLeftFn_<F extends HKT.URIS, C = HKT.Auto> {
  <N extends string, K, Q, W, X, I, S, R, E, A, B>(
    fa: HKT.Kind<F, C, N, K, Q, W, X, I, S, R, E, A>,
    b: B,
    f: (b: B, a: A) => B
  ): B;
}

export interface FoldLeftFnComposition<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> {
  <A, B>(b: B, f: (b: B, a: A) => B): <
    NF extends string,
    KF,
    QF,
    WF,
    XF,
    IF,
    SF,
    RF,
    EF,
    NG extends string,
    KG,
    QG,
    WG,
    XG,
    IG,
    SG,
    RG,
    EG
  >(
    fga: HKT.Kind<
      F,
      CF,
      NF,
      KF,
      QF,
      WF,
      XF,
      IF,
      SF,
      RF,
      EF,
      HKT.Kind<G, CG, NG, KG, QG, WG, XG, IG, SG, RG, EG, A>
    >
  ) => B;
}

export interface FoldLeftFnComposition_<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> {
  <
    NF extends string,
    KF,
    QF,
    WF,
    XF,
    IF,
    SF,
    RF,
    EF,
    NG extends string,
    KG,
    QG,
    WG,
    XG,
    IG,
    SG,
    RG,
    EG,
    A,
    B
  >(
    fga: HKT.Kind<
      F,
      CF,
      NF,
      KF,
      QF,
      WF,
      XF,
      IF,
      SF,
      RF,
      EF,
      HKT.Kind<G, CG, NG, KG, QG, WG, XG, IG, SG, RG, EG, A>
    >,
    b: B,
    f: (b: B, a: A) => B
  ): B;
}

export interface FoldRightFn<F extends HKT.URIS, C = HKT.Auto> {
  <A, B>(b: B, f: (a: A, b: B) => B): <N extends string, K, Q, W, X, I, S, R, E>(
    fa: HKT.Kind<F, C, N, K, Q, W, X, I, S, R, E, A>
  ) => B;
}

export interface FoldRightFn_<F extends HKT.URIS, C = HKT.Auto> {
  <N extends string, K, Q, W, X, I, S, R, E, A, B>(
    fa: HKT.Kind<F, C, N, K, Q, W, X, I, S, R, E, A>,
    b: B,
    f: (a: A, b: B) => B
  ): B;
}

export interface FoldRightFnComposition<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> {
  <A, B>(b: B, f: (a: A, b: B) => B): <
    FN extends string,
    FK,
    FQ,
    FW,
    FX,
    FI,
    FS,
    FR,
    FE,
    GN extends string,
    GK,
    GQ,
    GW,
    GX,
    GI,
    GS,
    GR,
    GE
  >(
    fa: HKT.Kind<
      F,
      CF,
      FN,
      FK,
      FQ,
      FW,
      FX,
      FI,
      FS,
      FR,
      FE,
      HKT.Kind<G, CG, GN, GK, GQ, GW, GX, GI, GS, GR, GE, A>
    >
  ) => B;
}

export interface FoldRightFnComposition_<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> {
  <
    FN extends string,
    FK,
    FQ,
    FW,
    FX,
    FI,
    FS,
    FR,
    FE,
    GN extends string,
    GK,
    GQ,
    GW,
    GX,
    GI,
    GS,
    GR,
    GE,
    A,
    B
  >(
    fa: HKT.Kind<
      F,
      CF,
      FN,
      FK,
      FQ,
      FW,
      FX,
      FI,
      FS,
      FR,
      FE,
      HKT.Kind<G, CG, GN, GK, GQ, GW, GX, GI, GS, GR, GE, A>
    >,
    b: B,
    f: (a: A, b: B) => B
  ): B;
}

export interface FoldMapFn<F extends HKT.URIS, C = HKT.Auto> {
  <M>(M: Monoid<M>): <A>(
    f: (a: A) => M
  ) => <N extends string, K, Q, W, X, I, S, R, E>(
    fa: HKT.Kind<F, C, N, K, Q, W, X, I, S, R, E, A>
  ) => M;
}

export interface FoldMapFn_<F extends HKT.URIS, C = HKT.Auto> {
  <M>(M: Monoid<M>): <N extends string, K, Q, W, X, I, S, R, E, A>(
    fa: HKT.Kind<F, C, N, K, Q, W, X, I, S, R, E, A>,
    f: (a: A) => M
  ) => M;
}

export interface FoldMapFnComposition<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> {
  <M>(M: Monoid<M>): <A>(
    f: (a: A) => M
  ) => <
    NF extends string,
    KF,
    QF,
    WF,
    XF,
    IF,
    SF,
    RF,
    EF,
    NG extends string,
    KG,
    QG,
    WG,
    XG,
    IG,
    SG,
    RG,
    EG
  >(
    fga: HKT.Kind<
      F,
      CF,
      NF,
      KF,
      QF,
      WF,
      XF,
      IF,
      SF,
      RF,
      EF,
      HKT.Kind<G, CG, NG, KG, QG, WG, XG, IG, SG, RG, EG, A>
    >
  ) => M;
}

export interface FoldMapFnComposition_<
  F extends HKT.URIS,
  G extends HKT.URIS,
  CF = HKT.Auto,
  CG = HKT.Auto
> {
  <M>(M: Monoid<M>): <
    NF extends string,
    KF,
    QF,
    WF,
    XF,
    IF,
    SF,
    RF,
    EF,
    NG extends string,
    KG,
    QG,
    WG,
    XG,
    IG,
    SG,
    RG,
    EG,
    A
  >(
    fga: HKT.Kind<
      F,
      CF,
      NF,
      KF,
      QF,
      WF,
      XF,
      IF,
      SF,
      RF,
      EF,
      HKT.Kind<G, CG, NG, KG, QG, WG, XG, IG, SG, RG, EG, A>
    >,
    f: (a: A) => M
  ) => M;
}
